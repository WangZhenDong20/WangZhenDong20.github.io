<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="SleepingFace Blog"><meta property="og:type" content="article"><meta property="og:image" content="https://wangzhendong20.github.io//img/home1.jpg"><meta property="twitter:image" content="https://wangzhendong20.github.io//img/home1.jpg"><meta name=title content="代码随想录+leetcode笔记"><meta property="og:title" content="代码随想录+leetcode笔记"><meta property="twitter:title" content="代码随想录+leetcode笔记"><meta name=description content="记录一些自己理解的关键点，以及一些常见的错误。"><meta property="og:description" content="记录一些自己理解的关键点，以及一些常见的错误。"><meta property="twitter:description" content="记录一些自己理解的关键点，以及一些常见的错误。"><meta property="twitter:card" content="summary"><meta name=keyword content="WangZhendong"><link rel="shortcut icon" href=/img/favicon.ico><title>代码随想录+leetcode笔记 | 王振东的博客 | WangZhendong Blog</title>
<link rel=canonical href=/2024/07/22/leetcode-note/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>SleepingFace Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/tech/>tech</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/notes//>NOTES</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home1.jpg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/java title=Java>Java
</a><a class=tag href=/tags/leetcode title=LeetCode>LeetCode
</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95 title=算法>算法</a></div><h1>代码随想录+leetcode笔记</h1><h2 class=subheading>记录一些自己理解的关键点，以及一些常见的错误</h2><span class=meta>Posted by
SleepingFace
on
Monday, July 22, 2024</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=一些工具类方法>一些工具类方法</h1><h2 id=collections>Collections</h2><h3 id=排序操作httpsjavaguidecnjavacollectionjava-collection-questions-02html排序操作><a href=https://javaguide.cn/java/collection/java-collection-questions-02.html#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C>排序操作</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>reverse</span>(List list)<span style=color:#6272a4>//反转</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>shuffle</span>(List list)<span style=color:#6272a4>//随机排序</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>sort</span>(List list)<span style=color:#6272a4>//按自然排序的升序排序</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>sort</span>(List list, Comparator c)<span style=color:#6272a4>//定制排序，由Comparator控制排序逻辑</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>swap</span>(List list, <span style=color:#8be9fd>int</span> i , <span style=color:#8be9fd>int</span> j)<span style=color:#6272a4>//交换两个索引位置的元素</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>rotate</span>(List list, <span style=color:#8be9fd>int</span> distance)<span style=color:#6272a4>//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span>
</span></span></code></pre></div><h3 id=查找替换操作>查找替换操作</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>binarySearch</span>(List list, Object key)<span style=color:#6272a4>//对List进行二分查找，返回索引，注意List必须是有序的</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>max</span>(Collection coll)<span style=color:#6272a4>//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>max</span>(Collection coll, Comparator c)<span style=color:#6272a4>//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>fill</span>(List list, Object obj)<span style=color:#6272a4>//用指定的元素代替指定list中的所有元素</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>frequency</span>(Collection c, Object o)<span style=color:#6272a4>//统计元素出现次数</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>indexOfSubList</span>(List list, List target)<span style=color:#6272a4>//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>replaceAll</span>(List list, Object oldVal, Object newVal)<span style=color:#6272a4>//用新元素替换旧元素</span>
</span></span></code></pre></div><h2 id=systemarraycopy函数>System.arraycopy()函数</h2><h2 id=一维数组排序>一维数组排序</h2><p>使用stream流的方式来进行排序</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Arrays.<span style=color:#50fa7b>stream</span>(arr).<span style=color:#50fa7b>boxed</span>().<span style=color:#50fa7b>sorted</span>(<span style=color:#ff79c6>new</span> Comparator<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>() {
</span></span><span style=display:flex><span>        @Override
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>compare</span>(Integer o1, Integer o2) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> count1 <span style=color:#ff79c6>=</span> CalBit(o1);
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> count2 <span style=color:#ff79c6>=</span> CalBit(o2);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (count1 <span style=color:#ff79c6>==</span> count2) <span style=color:#ff79c6>return</span> Integer.<span style=color:#50fa7b>compare</span>(o1,o2);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> Integer.<span style=color:#50fa7b>compare</span>(count1,count2);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }).<span style=color:#50fa7b>mapToInt</span>(Integer::intValue).<span style=color:#50fa7b>toArray</span>();
</span></span></code></pre></div><h1 id=1数组>1.数组</h1><h2 id=11-做题总结与技巧>1.1 做题总结与技巧</h2><p><strong>对于数组的题目，大多使用双指针法、快慢指针法、滑动窗口方法。还有的题目需要模拟过程，要注意区间的选择，是左闭右开还是左闭右闭等。</strong></p><h3 id=二分查找>二分查找</h3><h3 id=双指针法>双指针法</h3><h3 id=快慢指针法>快慢指针法</h3><h3 id=滑动窗口>滑动窗口</h3><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>例：<a href=https://leetcode.cn/problems/minimum-size-subarray-sum/>209. 长度最小的子数组</a></p><p>用一个for循环，那么这个循环的索引，一定是表示 <strong>滑动窗口的终止位置</strong>。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ target 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于target 了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src=/img/2024-07-22-leetcode-note/assets/20210312160441942.png alt=滑动窗口></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p><h3 id=旋转的题目先转一个区域再全旋转数组旋转数组httpsprogrammercarlcom0189旋转数组html>旋转的题目，先转一个区域，再全旋转<a href=https://programmercarl.com/0189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84.html>数组：旋转数组</a></h3><p>这类题和字符转中旋转的题是一种类型</p><p>有一点要注意！</p><p>如果k大于了数组长度怎么办？ -> <code>k = k%nums.length</code></p><h2 id=12-重点题目及出错的题目等>1.2 重点题目及出错的题目等</h2><h3 id=34-在排序数组中查找元素的第一个和最后一个位置httpsleetcodecnproblemsfind-first-and-last-position-of-element-in-sorted-array><a href=https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/>34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>使用二分查找</p><p>其中<strong>确定好计算出来的左边界是不包含target的左边界，左边界同理。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>middle34</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>searchRange</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> leftBorder <span style=color:#ff79c6>=</span> getleftBorder(nums,target);
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> rightBorder <span style=color:#ff79c6>=</span> getrightBorder(nums,target);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (leftBorder <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>-</span>2 <span style=color:#ff79c6>||</span> rightBorder <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>-</span>2) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{<span style=color:#ff79c6>-</span>1,<span style=color:#ff79c6>-</span>1};
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (rightBorder <span style=color:#ff79c6>-</span> leftBorder <span style=color:#ff79c6>&gt;</span> 1) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{leftBorder <span style=color:#ff79c6>+</span> 1,rightBorder <span style=color:#ff79c6>-</span> 1};
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{<span style=color:#ff79c6>-</span>1,<span style=color:#ff79c6>-</span>1};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>getleftBorder</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> leftBorder <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>2;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;=</span> right) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> mid <span style=color:#ff79c6>=</span> left <span style=color:#ff79c6>+</span> (right <span style=color:#ff79c6>-</span> left) <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> target) {
</span></span><span style=display:flex><span>                left <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 计算出来的左边界是不包含target的左边界，左边界同理。</span>
</span></span><span style=display:flex><span>                right <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>                leftBorder <span style=color:#ff79c6>=</span> right;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> leftBorder;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>getrightBorder</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> rightBorder <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>2;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;=</span> right) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> mid <span style=color:#ff79c6>=</span> left <span style=color:#ff79c6>+</span> (right <span style=color:#ff79c6>-</span> left) <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> target) {
</span></span><span style=display:flex><span>                right <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                left <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>                rightBorder <span style=color:#ff79c6>=</span> left;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> rightBorder;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=844-比较含退格的字符串httpsleetcodecnproblemsbackspace-string-compare><a href=https://leetcode.cn/problems/backspace-string-compare/>844. 比较含退格的字符串</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>//将字符数组转为String  </span>
</span></span><span style=display:flex><span>String.<span style=color:#50fa7b>valueOf</span>(strChars)
</span></span><span style=display:flex><span><span style=color:#6272a4>// 不要使用.toString()</span>
</span></span></code></pre></div><h3 id=977-有序数组的平方httpsleetcodecnproblemssquares-of-a-sorted-array><a href=https://leetcode.cn/problems/squares-of-a-sorted-array/>977. 有序数组的平方</a></h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] >= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>sortedSquares</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> k <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (Math.<span style=color:#50fa7b>abs</span>(nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>&gt;</span> Math.<span style=color:#50fa7b>abs</span>(nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>)) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>[</span>k<span style=color:#ff79c6>--]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>*</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (Math.<span style=color:#50fa7b>abs</span>(nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>&lt;=</span> Math.<span style=color:#50fa7b>abs</span>(nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>)) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>[</span>k<span style=color:#ff79c6>--]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>*</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=209-长度最小的子数组httpsleetcodecnproblemsminimum-size-subarray-sum><a href=https://leetcode.cn/problems/minimum-size-subarray-sum/>209. 长度最小的子数组</a></h3><p><strong>滑动窗口</strong>案例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> sum <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> Integer.<span style=color:#50fa7b>MAX_VALUE</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> 0; right <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; right<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    sum <span style=color:#ff79c6>+=</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (sum <span style=color:#ff79c6>&gt;=</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> subLength <span style=color:#ff79c6>=</span> right <span style=color:#ff79c6>-</span> left <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>        ans <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(ans, subLength);
</span></span><span style=display:flex><span>        sum <span style=color:#ff79c6>-=</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>return</span> ans <span style=color:#ff79c6>==</span> Integer.<span style=color:#50fa7b>MAX_VALUE</span> <span style=color:#ff79c6>?</span> 0 : ans;
</span></span></code></pre></div><h3 id=904-水果成篮httpsleetcodecnproblemsfruit-into-baskets><a href=https://leetcode.cn/problems/fruit-into-baskets/>904. 水果成篮</a></h3><p>滑动窗口 求最大窗口</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>totalFruit</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> fruits) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    HashMap<span style=color:#ff79c6>&lt;</span>Integer,Integer<span style=color:#ff79c6>&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> 0; right <span style=color:#ff79c6>&lt;</span> fruits.<span style=color:#50fa7b>length</span>; right<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        map.<span style=color:#50fa7b>put</span>(fruits<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>,map.<span style=color:#50fa7b>getOrDefault</span>(fruits<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>,0) <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (map.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 2 ) {
</span></span><span style=display:flex><span>            map.<span style=color:#50fa7b>put</span>(fruits<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>,map.<span style=color:#50fa7b>get</span>(fruits<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>-</span> 1);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (map.<span style=color:#50fa7b>get</span>(fruits<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>                map.<span style=color:#50fa7b>remove</span>(fruits<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>++</span>left;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ans <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(ans, right <span style=color:#ff79c6>-</span> left <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=76-最小覆盖子串httpsleetcodecnproblemsminimum-window-substring><a href=https://leetcode.cn/problems/minimum-window-substring/>76. 最小覆盖子串</a></h3><p>滑动窗口 求最小窗口</p><p><strong>如何判断滑动窗口包含了T的所有元素？</strong>
我们用一个字典need来表示当前滑动窗口中需要的各元素的数量，一开始滑动窗口为空，用T中各元素来初始化这个need，当滑动窗口扩展或者收缩的时候，去维护这个need字典，例如当滑动窗口包含某个元素，我们就让need中这个元素的数量减1，代表所需元素减少了1个；当滑动窗口移除某个元素，就让need中这个元素的数量加1。
记住一点：need始终记录着当前滑动窗口下，我们还需要的元素数量，我们在改变i,j时，需同步维护need。
值得注意的是，只要某个元素包含在滑动窗口中，我们就会在need中存储这个元素的数量，如果某个元素存储的是负数代表这个元素是多余的。比如当need等于{&lsquo;A&rsquo;:-2,&lsquo;C&rsquo;:1}时，表示当前滑动窗口中，我们有2个A是多余的，同时还需要1个C。这么做的目的就是为了步骤二中，排除不必要的元素，数量为负的就是不必要的元素，而数量为0表示刚刚好。
回到问题中来，那么如何判断滑动窗口包含了T的所有元素？结论就是当need中所有元素的数量都小于等于0时，表示当前滑动窗口不再需要任何元素。
<strong>优化</strong>
如果每次判断滑动窗口是否包含了T的所有元素，都去遍历need看是否所有元素数量都小于等于0，这个会耗费O(k)O(k)O(k)的时间复杂度，k代表字典长度，最坏情况下，k可能等于len(S)。
其实这个是可以避免的，我们可以维护一个额外的变量needCnt来记录所需元素的总数量，当我们碰到一个所需元素c，不仅need[c]的数量减少1，同时needCnt也要减少1，这样我们通过needCnt就可以知道是否满足条件，而无需遍历字典了。
前面也提到过，need记录了遍历到的所有元素，而只有need[c]>0大于0时，代表c就是所需元素</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> String <span style=color:#50fa7b>minWindow</span>(String s, String t) {
</span></span><span style=display:flex><span>    HashMap<span style=color:#ff79c6>&lt;</span>Character,Integer<span style=color:#ff79c6>&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> t.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        map.<span style=color:#50fa7b>put</span>(t.<span style=color:#50fa7b>charAt</span>(i),map.<span style=color:#50fa7b>getOrDefault</span>(t.<span style=color:#50fa7b>charAt</span>(i),0) <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//将所需要的字符加入到map中，count为所需字符的数量</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> size <span style=color:#ff79c6>=</span> Integer.<span style=color:#50fa7b>MAX_VALUE</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0, count <span style=color:#ff79c6>=</span> t.<span style=color:#50fa7b>length</span>(), start <span style=color:#ff79c6>=</span> 0;   <span style=color:#6272a4>// start为最终的开始位置</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> 0; right <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); right<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>char</span> c <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>charAt</span>(right);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//如果需要该字符就减少count</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (map.<span style=color:#50fa7b>containsKey</span>(c) <span style=color:#ff79c6>&amp;&amp;</span> map.<span style=color:#50fa7b>get</span>(c) <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        map.<span style=color:#50fa7b>put</span>(c, map.<span style=color:#50fa7b>getOrDefault</span>(c,0)<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (count <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//当前窗口满了</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (map.<span style=color:#50fa7b>get</span>(s.<span style=color:#50fa7b>charAt</span>(left)) <span style=color:#ff79c6>&lt;</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 排除不必要的字符</span>
</span></span><span style=display:flex><span>                map.<span style=color:#50fa7b>put</span>(s.<span style=color:#50fa7b>charAt</span>(left),map.<span style=color:#50fa7b>get</span>(s.<span style=color:#50fa7b>charAt</span>(left)) <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>                left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 确定最小长度</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (right <span style=color:#ff79c6>-</span> left <span style=color:#ff79c6>+</span> 1 <span style=color:#ff79c6>&lt;</span> size) {
</span></span><span style=display:flex><span>                size <span style=color:#ff79c6>=</span> right <span style=color:#ff79c6>-</span> left <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>                start <span style=color:#ff79c6>=</span> left;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//左边减小窗口</span>
</span></span><span style=display:flex><span>            map.<span style=color:#50fa7b>put</span>(s.<span style=color:#50fa7b>charAt</span>(left),map.<span style=color:#50fa7b>get</span>(s.<span style=color:#50fa7b>charAt</span>(left)) <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>            left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> size <span style=color:#ff79c6>==</span> Integer.<span style=color:#50fa7b>MAX_VALUE</span> <span style=color:#ff79c6>?</span> <span style=color:#f1fa8c>&#34;&#34;</span> : s.<span style=color:#50fa7b>substring</span>(start,start<span style=color:#ff79c6>+</span>size);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=59-螺旋矩阵-iihttpsleetcodecnproblemsspiral-matrix-ii><a href=https://leetcode.cn/problems/spiral-matrix-ii/>59. 螺旋矩阵 II</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> <span style=color:#50fa7b>generateMatrix</span>(<span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//左闭右开</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> startx <span style=color:#ff79c6>=</span> 0, starty <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> loop <span style=color:#ff79c6>=</span> n<span style=color:#ff79c6>/</span>2;  <span style=color:#6272a4>//需要循环n/2次，因为是n/2层</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> offset <span style=color:#ff79c6>=</span> 1; <span style=color:#6272a4>//记录偏移，即层数</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (loop<span style=color:#ff79c6>--</span> <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startx;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> starty;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (; j <span style=color:#ff79c6>&lt;</span> n <span style=color:#ff79c6>-</span> offset; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> count;
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (; i <span style=color:#ff79c6>&lt;</span> n <span style=color:#ff79c6>-</span> offset; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> count;
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (; j <span style=color:#ff79c6>&gt;</span> starty; j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> count;
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (; i <span style=color:#ff79c6>&gt;</span> startx; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> count;
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        startx<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        starty<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        offset<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (n <span style=color:#ff79c6>%</span> 2 <span style=color:#ff79c6>!=</span> 0) {
</span></span><span style=display:flex><span>        ans<span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>/</span>2<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>/</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=54-螺旋矩阵httpsleetcodecnproblemsspiral-matrix><a href=https://leetcode.cn/problems/spiral-matrix/>54. 螺旋矩阵</a></h3><p>注意区间的左闭右开还是左闭右闭</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>spiralOrder</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> matrix) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m <span style=color:#ff79c6>=</span> matrix.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> loop <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(m,n) <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> offset <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> startx <span style=color:#ff79c6>=</span> 0, starty <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (loop<span style=color:#ff79c6>--</span> <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startx;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> starty;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (; j <span style=color:#ff79c6>&lt;</span> n <span style=color:#ff79c6>-</span> offset; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            ans.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (; i <span style=color:#ff79c6>&lt;</span> m <span style=color:#ff79c6>-</span> offset; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            ans.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (; j <span style=color:#ff79c6>&gt;</span> starty; j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            ans.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (; i <span style=color:#ff79c6>&gt;</span> startx; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            ans.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        startx<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        starty<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        offset<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (Math.<span style=color:#50fa7b>min</span>(m,n) <span style=color:#ff79c6>%</span> 2 <span style=color:#ff79c6>==</span> 1) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (m <span style=color:#ff79c6>&gt;</span> n) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> k <span style=color:#ff79c6>=</span> 0; k <span style=color:#ff79c6>&lt;</span> loop <span style=color:#ff79c6>+</span> m <span style=color:#ff79c6>-</span> n <span style=color:#ff79c6>+</span> 1; k<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>                ans.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>k<span style=color:#ff79c6>][</span>loop<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> k <span style=color:#ff79c6>=</span> 0; k <span style=color:#ff79c6>&lt;</span> loop <span style=color:#ff79c6>+</span> m <span style=color:#ff79c6>-</span> n <span style=color:#ff79c6>+</span> 1; k<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>                ans.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>loop<span style=color:#ff79c6>][</span>k<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>spiralOrder2</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> matrix) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//左闭右闭</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m <span style=color:#ff79c6>=</span> matrix.<span style=color:#50fa7b>length</span>, n <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//上下左右</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> u <span style=color:#ff79c6>=</span> 0, d <span style=color:#ff79c6>=</span> m <span style=color:#ff79c6>-</span> 1, l <span style=color:#ff79c6>=</span> 0, r <span style=color:#ff79c6>=</span> n <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> l; i <span style=color:#ff79c6>&lt;=</span> r; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            res.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>++</span>u <span style=color:#ff79c6>&gt;</span> d) <span style=color:#ff79c6>break</span>;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> u; i <span style=color:#ff79c6>&lt;=</span> d; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            res.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>r<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>--</span>r <span style=color:#ff79c6>&lt;</span> l) <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> r; i <span style=color:#ff79c6>&gt;=</span> l; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            res.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>d<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>--</span>d <span style=color:#ff79c6>&lt;</span> u) <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> d; i <span style=color:#ff79c6>&gt;=</span> u; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            res.<span style=color:#50fa7b>add</span>(matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>l<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>++</span>l <span style=color:#ff79c6>&gt;</span> r) <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=数组寻找数组的中心索引httpsprogrammercarlcom0724寻找数组的中心索引html><a href=https://programmercarl.com/0724.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95.html>数组：寻找数组的中心索引</a></h3><ol><li><p>遍历一遍求出总和sum</p></li><li><p>遍历第二遍求中心索引左半和leftSum</p><ul><li>同时根据sum和leftSum 计算中心索引右半和rightSum</li><li>判断leftSum和rightSum是否相同</li></ul><p>leftSum和rightSum是包含中心的和。</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>pivotIndex</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> sum <span style=color:#ff79c6>=</span> Arrays.<span style=color:#50fa7b>stream</span>(nums).<span style=color:#50fa7b>sum</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> leftSum <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> rightSum <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        leftSum <span style=color:#ff79c6>+=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        rightSum <span style=color:#ff79c6>=</span> sum <span style=color:#ff79c6>-</span> leftSum <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (leftSum <span style=color:#ff79c6>==</span> rightSum) <span style=color:#ff79c6>return</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=2链表>2.链表</h1><h2 id=21-做题总结与技巧>2.1 做题总结与技巧</h2><p>掌握好插入和删除的逻辑</p><h3 id=虚拟头结点>虚拟头结点</h3><h3 id=翻转链表两两交换节点>翻转链表、两两交换节点</h3><h3 id=双指针快慢指针>双指针、快慢指针</h3><h3 id=找中点断开翻转拼接>找中点、断开、翻转、拼接</h3><h2 id=22-重点题目及出错的题目等>2.2 重点题目及出错的题目等</h2><h3 id=206-反转链表httpsleetcodecnproblemsreverse-linked-list><a href=https://leetcode.cn/problems/reverse-linked-list/>206. 反转链表</a></h3><p>用一个temp来存cur.next，之后用将cur.next指向pre，之后更新pre为下一个即cur，最后更新cur=temp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ListNode <span style=color:#50fa7b>reverseList</span>(ListNode head) {
</span></span><span style=display:flex><span>    ListNode pre <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    ListNode cur <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode temp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (cur <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        temp <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> pre;
</span></span><span style=display:flex><span>        pre <span style=color:#ff79c6>=</span> cur;
</span></span><span style=display:flex><span>        cur <span style=color:#ff79c6>=</span> temp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> pre;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=24-两两交换链表中的节点httpsleetcodecnproblemsswap-nodes-in-pairs><a href=https://leetcode.cn/problems/swap-nodes-in-pairs/>24. 两两交换链表中的节点</a></h3><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-08_15-37-23.png alt=两两交换节点></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ListNode <span style=color:#50fa7b>swapPairs</span>(ListNode head) {
</span></span><span style=display:flex><span>    ListNode dummy <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ListNode(0);
</span></span><span style=display:flex><span>    dummy.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode cur <span style=color:#ff79c6>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> cur.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//记录1和3节点</span>
</span></span><span style=display:flex><span>        ListNode tmp <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        ListNode tmp1 <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        cur.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>        cur.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> tmp1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dummy.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=19-删除链表的倒数第-n-个结点httpsleetcodecnproblemsremove-nth-node-from-end-of-list><a href=https://leetcode.cn/problems/remove-nth-node-from-end-of-list/>19. 删除链表的倒数第 N 个结点</a></h3><p>快慢指针，首先定义一个dummy，之后让fast先走N步，之后让fast和slow走到末尾，此时slow就是要删除节点的前一个节点</p><p>只要slow和fast之间相差N-1个节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ListNode <span style=color:#50fa7b>removeNthFromEnd</span>(ListNode head, <span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>    ListNode dummy <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ListNode();
</span></span><span style=display:flex><span>    dummy.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode fast <span style=color:#ff79c6>=</span> dummy;
</span></span><span style=display:flex><span>    ListNode slow <span style=color:#ff79c6>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> n <span style=color:#ff79c6>&amp;&amp;</span> fast.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        fast <span style=color:#ff79c6>=</span> fast.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (fast.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        fast <span style=color:#ff79c6>=</span> fast.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        slow <span style=color:#ff79c6>=</span> slow.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    slow.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> slow.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dummy.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>**<a href=https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/>面试题 02.07. 链表相交</a>**一样的类型题，这个需要算出来相差多少之后确定一个是长的链表，然后快慢指针解决。</p><h3 id=142-环形链表-iihttpsleetcodecnproblemslinked-list-cycle-ii><a href=https://leetcode.cn/problems/linked-list-cycle-ii/>142. 环形链表 II</a></h3><p>先找出环再找出环的节点，其中fast指针每次两格，slow每次一格。</p><p><a href=https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF>https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ListNode <span style=color:#50fa7b>detectCycle</span>(ListNode head) {
</span></span><span style=display:flex><span>    ListNode slow <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode fast <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (fast <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> fast.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        fast <span style=color:#ff79c6>=</span> fast.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        slow <span style=color:#ff79c6>=</span> slow.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (slow <span style=color:#ff79c6>==</span> fast) {
</span></span><span style=display:flex><span>            ListNode index1 <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>            ListNode index2 <span style=color:#ff79c6>=</span> fast;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (index1 <span style=color:#ff79c6>!=</span> index2) {
</span></span><span style=display:flex><span>                index1 <span style=color:#ff79c6>=</span> index1.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>                index2 <span style=color:#ff79c6>=</span> index2.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> index1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表回文链表httpsprogrammercarlcom0234回文链表html><a href=https://programmercarl.com/0234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html>链表：回文链表</a></h3><p><strong>反转后半部分链表</strong></p><p>分为如下几步：</p><ul><li>用快慢指针，快指针有两步，慢指针走一步，快指针遇到终止位置时，慢指针就在链表中间位置</li><li>同时用pre记录慢指针指向节点的前一个节点，用来分割链表</li><li>将链表分为前后均等两部分，如果链表长度是奇数，那么后半部分多一个节点</li><li>将后半部分反转 ，得cur2，前半部分为cur1</li><li>按照cur1的长度，一次比较cur1和cur2的节点数值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isPalindrome</span>(ListNode head) {
</span></span><span style=display:flex><span>    ListNode slow <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode fast <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode pre <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (fast <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> fast.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        pre <span style=color:#ff79c6>=</span> slow;
</span></span><span style=display:flex><span>        fast <span style=color:#ff79c6>=</span> fast.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        slow <span style=color:#ff79c6>=</span> slow.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    pre.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    ListNode cur1 <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode cur2 <span style=color:#ff79c6>=</span> reverseList(slow);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (cur1 <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (cur1.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>!=</span> cur2.<span style=color:#50fa7b>val</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        cur1 <span style=color:#ff79c6>=</span> cur1.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        cur2 <span style=color:#ff79c6>=</span> cur2.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> ListNode <span style=color:#50fa7b>reverseList</span>(ListNode head) {
</span></span><span style=display:flex><span>    ListNode pre <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    ListNode cur <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode tmp;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (cur <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        tmp <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> pre;
</span></span><span style=display:flex><span>        pre <span style=color:#ff79c6>=</span> cur;
</span></span><span style=display:flex><span>        cur <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> pre;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://programmercarl.com/0143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.html>链表：重排链表</a>也是相同的题型。</p><p>找中点，断开，反转后半段，再拼接。</p><h1 id=3哈希表>3.哈希表</h1><h2 id=31-做题总结与技巧>3.1 做题总结与技巧</h2><h3 id=当我们遇到了要快速判断一个元素是否出现集合里的时候就要考虑哈希法><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</h3><h3 id=数组mapset都可以作为哈希表><strong>数组、map、set</strong>都可以作为哈希表</h3><p>首先在一个集合记录出现的字符串中的字符，之后再遍历并一个字符串在集合中减掉。</p><h2 id=32-重点题目及出错的题目等>3.2 重点题目及出错的题目等</h2><h3 id=49-字母异位词分组httpsleetcodecnproblemsgroup-anagrams><a href=https://leetcode.cn/problems/group-anagrams/>49. 字母异位词分组</a></h3><p>将字符串转为数组进行排序，这样相同数量的字符串就会一个样子，然后加入到map里。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>groupAnagrams</span>(String<span style=color:#ff79c6>[]</span> strs) {
</span></span><span style=display:flex><span>    HashMap<span style=color:#ff79c6>&lt;</span>String,List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (String str : strs) {
</span></span><span style=display:flex><span>        String changeStr <span style=color:#ff79c6>=</span> change(str);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (map.<span style=color:#50fa7b>containsKey</span>(changeStr)) {
</span></span><span style=display:flex><span>            map.<span style=color:#50fa7b>get</span>(changeStr).<span style=color:#50fa7b>add</span>(str);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> list <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            list.<span style=color:#50fa7b>add</span>(str);
</span></span><span style=display:flex><span>            map.<span style=color:#50fa7b>put</span>(changeStr,list);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (Map.<span style=color:#50fa7b>Entry</span><span style=color:#ff79c6>&lt;</span>String, List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> entry : map.<span style=color:#50fa7b>entrySet</span>()) {
</span></span><span style=display:flex><span>        ans.<span style=color:#50fa7b>add</span>(entry.<span style=color:#50fa7b>getValue</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> String <span style=color:#50fa7b>change</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> chars <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>toCharArray</span>();
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(chars);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> String.<span style=color:#50fa7b>valueOf</span>(chars);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>groupAnagrams2</span>(String<span style=color:#ff79c6>[]</span> strs) {
</span></span><span style=display:flex><span>    Map<span style=color:#ff79c6>&lt;</span>String, List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;</span>String, List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(String str : strs){
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>[]</span> array <span style=color:#ff79c6>=</span> str.<span style=color:#50fa7b>toCharArray</span>();
</span></span><span style=display:flex><span>        Arrays.<span style=color:#50fa7b>sort</span>(array);
</span></span><span style=display:flex><span>        String key <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> String(array);
</span></span><span style=display:flex><span>        List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> list <span style=color:#ff79c6>=</span> map.<span style=color:#50fa7b>getOrDefault</span>(key, <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span>());
</span></span><span style=display:flex><span>        list.<span style=color:#50fa7b>add</span>(str);
</span></span><span style=display:flex><span>        map.<span style=color:#50fa7b>put</span>(key,list);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span>(map.<span style=color:#50fa7b>values</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=438-找到字符串中所有字母异位词httpsleetcodecnproblemsfind-all-anagrams-in-a-string><a href=https://leetcode.cn/problems/find-all-anagrams-in-a-string/>438. 找到字符串中所有字母异位词</a></h3><p>使用数组作为哈希表，并使用滑动窗口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>findAnagrams</span>(String s, String p) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//O(n2)</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> pChar <span style=color:#ff79c6>=</span> p.<span style=color:#50fa7b>toCharArray</span>();
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(pChar);
</span></span><span style=display:flex><span>    p <span style=color:#ff79c6>=</span> String.<span style=color:#50fa7b>valueOf</span>(pChar);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> sChar <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>toCharArray</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> p.<span style=color:#50fa7b>length</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> sChar.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> len <span style=color:#ff79c6>+</span> 1; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> copy <span style=color:#ff79c6>=</span> Arrays.<span style=color:#50fa7b>copyOfRange</span>(sChar, i, i <span style=color:#ff79c6>+</span> len);
</span></span><span style=display:flex><span>        Arrays.<span style=color:#50fa7b>sort</span>(copy);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (String.<span style=color:#50fa7b>valueOf</span>(copy).<span style=color:#50fa7b>equals</span>(p)){
</span></span><span style=display:flex><span>            ans.<span style=color:#50fa7b>add</span>(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 将它转变为遍历s的时候一种“消耗品”——当“消耗品”不足，唯一可以做的就是移动左窗口释放一些出来。</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>findAnagrams2</span>(String s, String p) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//O(n)  滑动窗口</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> p_c <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>26<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>char</span> c : p.<span style=color:#50fa7b>toCharArray</span>()) p_c<span style=color:#ff79c6>[</span>c <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span><span style=color:#ff79c6>]++</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span>(right <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(p_c<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>charAt</span>(right) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span><span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> 0){
</span></span><span style=display:flex><span>            p_c<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>charAt</span>(right<span style=color:#ff79c6>++</span>) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span><span style=color:#ff79c6>]--</span>; <span style=color:#6272a4>// 消耗了一个</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span>(right <span style=color:#ff79c6>-</span> left <span style=color:#ff79c6>==</span> p.<span style=color:#50fa7b>length</span>()){
</span></span><span style=display:flex><span>                ans.<span style=color:#50fa7b>add</span>(left); <span style=color:#6272a4>// 这里不着急移，p_c不够再移</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span>{
</span></span><span style=display:flex><span>            p_c<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>charAt</span>(left<span style=color:#ff79c6>++</span>) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span><span style=color:#ff79c6>]++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=15-三数之和httpsleetcodecnproblems3sum><a href=https://leetcode.cn/problems/3sum/>15. 三数之和</a></h3><p><strong>双指针法</strong>解决，区别于<a href=https://leetcode.cn/problems/two-sum/>1. 两数之和</a>和<a href=https://leetcode.cn/problems/4sum-ii/>454. 四数相加 II</a>，三数之和中的数组不是独立的，需要考虑重复问题，而另两个是独立的。</p><p>其中的去重逻辑很重要。https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>threeSum</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(nums);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left,right;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 正确去重a方法</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>&gt;</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        left <span style=color:#ff79c6>=</span> i<span style=color:#ff79c6>+</span>1;
</span></span><span style=display:flex><span>        right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;</span> right) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> 0) right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> 0) left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                result.<span style=color:#50fa7b>add</span>(Arrays.<span style=color:#50fa7b>asList</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>,nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>while</span> (right <span style=color:#ff79c6>&gt;</span> left <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> nums<span style=color:#ff79c6>[</span>right <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>]</span>) right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>while</span> (right <span style=color:#ff79c6>&gt;</span> left <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> nums<span style=color:#ff79c6>[</span>left <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>]</span>) left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>                left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=18-四数之和httpsleetcodecnproblems4sum><a href=https://leetcode.cn/problems/4sum/>18. 四数之和</a></h3><p><a href=https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html>https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>fourSum</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(nums);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> target <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;=</span> 0) <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>&gt;</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> i<span style=color:#ff79c6>+</span>1; j <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]+</span>nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> target <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]+</span>nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;=</span> 0) <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>&gt;</span> i<span style=color:#ff79c6>+</span>1 <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> j<span style=color:#ff79c6>+</span>1;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;</span> right){
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> sum <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]+</span>nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]+</span>nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]+</span>nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> ( sum <span style=color:#ff79c6>==</span> target){
</span></span><span style=display:flex><span>                    res.<span style=color:#50fa7b>add</span>(Arrays.<span style=color:#50fa7b>asList</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>,nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>,nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>while</span> (left<span style=color:#ff79c6>&lt;</span>right <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>) left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>while</span> (left<span style=color:#ff79c6>&lt;</span>right <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                    right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>                }<span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (sum <span style=color:#ff79c6>&gt;</span> target){
</span></span><span style=display:flex><span>                    right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>                }<span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                    left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=4字符串>4.字符串</h1><h2 id=41-做题总结与技巧>4.1 做题总结与技巧</h2><h3 id=双指针在字符串题目中很常用><strong>双指针</strong>在字符串题目中很常用</h3><h3 id=局部翻转和全局翻转>局部翻转和全局翻转</h3><h3 id=kmp算法---6-实现strstrhttpsprogrammercarlcom0028实现strstrhtml><strong>KMP算法</strong> <a href=https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html>6. 实现strStr())</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>//获取next数组</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>getNext</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> next, String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>    next<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> j;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//不匹配</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (j <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>!=</span> s.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>            j <span style=color:#ff79c6>=</span> next<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//匹配</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>            j<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 将j（前缀的长度）赋给next[i]</span>
</span></span><span style=display:flex><span>        next<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//使用next数组，用模式串匹配文本串的整体代码</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>1; <span style=color:#6272a4>// 因为next数组里记录的起始位置为-1</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>size</span>(); i<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 注意i就从0开始</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span>(j <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>!=</span> t.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1) { <span style=color:#6272a4>// 不匹配</span>
</span></span><span style=display:flex><span>        j <span style=color:#ff79c6>=</span> next<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>; <span style=color:#6272a4>// j 寻找之前匹配的位置</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> t.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) { <span style=color:#6272a4>// 匹配，j和i同时向后移动</span>
</span></span><span style=display:flex><span>        j<span style=color:#ff79c6>++</span>; <span style=color:#6272a4>// i的增加在for循环里</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>==</span> (t.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>-</span> 1) ) { <span style=color:#6272a4>// 文本串s里出现了模式串t</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> (i <span style=color:#ff79c6>-</span> t.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=42-重点题目及出错的题目等>4.2 重点题目及出错的题目等</h2><h3 id=541-反转字符串-iihttpsleetcodecnproblemsreverse-string-ii><a href=https://leetcode.cn/problems/reverse-string-ii/>541. 反转字符串 II</a></h3><p><strong>当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> String <span style=color:#50fa7b>reverseStr</span>(String s, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> chars <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>toCharArray</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> chars.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>=</span>i<span style=color:#ff79c6>+</span>2<span style=color:#ff79c6>*</span>k) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>+</span> k <span style=color:#ff79c6>&lt;=</span> chars.<span style=color:#50fa7b>length</span>) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span>
</span></span><span style=display:flex><span>            reverse(chars,i,i<span style=color:#ff79c6>+</span>k);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//最后的k的字符</span>
</span></span><span style=display:flex><span>        reverse(chars,i,chars.<span style=color:#50fa7b>length</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> String.<span style=color:#50fa7b>valueOf</span>(chars);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>reverse</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> ch, <span style=color:#8be9fd>int</span> begin, <span style=color:#8be9fd>int</span> end) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> begin,j<span style=color:#ff79c6>=</span>end<span style=color:#ff79c6>-</span>1; i <span style=color:#ff79c6>&lt;</span> j; i<span style=color:#ff79c6>++</span>,j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>char</span> tmp <span style=color:#ff79c6>=</span> ch<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        ch<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> ch<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        ch<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=151-反转字符串中的单词httpsleetcodecnproblemsreverse-words-in-a-string><a href=https://leetcode.cn/problems/reverse-words-in-a-string/>151. 反转字符串中的单词</a></h3><p>注意删除空格时中间单词之间要留一个空格</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> String <span style=color:#50fa7b>reverseWords</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> ch <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>toCharArray</span>();
</span></span><span style=display:flex><span>    ch <span style=color:#ff79c6>=</span> removeExtraSpaces(ch);
</span></span><span style=display:flex><span>    reverse(ch,0,ch.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> start <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;=</span> ch.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>==</span> ch.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> ch<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39; &#39;</span>) {
</span></span><span style=display:flex><span>            reverse(ch,start,i<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>            start <span style=color:#ff79c6>=</span> i<span style=color:#ff79c6>+</span>1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> String.<span style=color:#50fa7b>valueOf</span>(ch);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>reverse</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> ch, <span style=color:#8be9fd>int</span> start, <span style=color:#8be9fd>int</span> end){ <span style=color:#6272a4>//翻转，区间写法：左闭右闭 []</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> start, j <span style=color:#ff79c6>=</span> end; i <span style=color:#ff79c6>&lt;</span> j; i<span style=color:#ff79c6>++</span>, j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>char</span> tmp <span style=color:#ff79c6>=</span> ch<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        ch<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> ch<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        ch<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>removeExtraSpaces</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> ch) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> slow <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> fast <span style=color:#ff79c6>=</span> 0; fast <span style=color:#ff79c6>&lt;</span> ch.<span style=color:#50fa7b>length</span>; fast<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (ch<span style=color:#ff79c6>[</span>fast<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>!=</span> <span style=color:#f1fa8c>&#39; &#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (slow <span style=color:#ff79c6>!=</span> 0) ch<span style=color:#ff79c6>[</span>slow<span style=color:#ff79c6>++]</span> <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39; &#39;</span>; <span style=color:#6272a4>//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (fast <span style=color:#ff79c6>&lt;</span> ch.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>&amp;&amp;</span> ch<span style=color:#ff79c6>[</span>fast<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>!=</span> <span style=color:#f1fa8c>&#39; &#39;</span>){
</span></span><span style=display:flex><span>                ch<span style=color:#ff79c6>[</span>slow<span style=color:#ff79c6>++]</span> <span style=color:#ff79c6>=</span> ch<span style=color:#ff79c6>[</span>fast<span style=color:#ff79c6>++]</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> Arrays.<span style=color:#50fa7b>copyOfRange</span>(ch,0,slow);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=28-找出字符串中第一个匹配项的下标httpsleetcodecnproblemsfind-the-index-of-the-first-occurrence-in-a-string><a href=https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/>28. 找出字符串中第一个匹配项的下标</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>strStr</span>(String haystack, String needle) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (needle.<span style=color:#50fa7b>length</span>() <span style=color:#ff79c6>==</span> 0) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> next <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>needle.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    getNext(next,needle);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> haystack.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (j <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> haystack.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>!=</span> needle.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>            j <span style=color:#ff79c6>=</span> next<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (haystack.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> needle.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>            j<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>==</span> needle.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> (i <span style=color:#ff79c6>-</span> needle.<span style=color:#50fa7b>length</span>() <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>getNext</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> next, String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>    next<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> j;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//不匹配</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (j <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>!=</span> s.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>            j <span style=color:#ff79c6>=</span> next<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//匹配</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>            j<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 将j（前缀的长度）赋给next[i]</span>
</span></span><span style=display:flex><span>        next<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=459-重复的子字符串httpsleetcodecnproblemsrepeated-substring-pattern><a href=https://leetcode.cn/problems/repeated-substring-pattern/>459. 重复的子字符串</a></h3><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-08_22-33-31.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>repeatedSubstringPattern</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>length</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> next <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>len<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    getNext(next,s);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (next<span style=color:#ff79c6>[</span>len<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> ！<span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>1 <span style=color:#ff79c6>&amp;&amp;</span> len <span style=color:#ff79c6>%</span> (len <span style=color:#ff79c6>-</span> (next<span style=color:#ff79c6>[</span>len<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1)) <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>getNext</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> next, String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>    next<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> j;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (j <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>!=</span> s.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>            j <span style=color:#ff79c6>=</span> next<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>            j<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        next<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=5栈和队列>5.栈和队列</h1><h2 id=51-做题总结与技巧>5.1 做题总结与技巧</h2><h3 id=匹配问题>匹配问题</h3><h3 id=单调队列根据场景自己设计>单调队列（根据场景自己设计）</h3><h3 id=优先级队列>优先级队列</h3><h2 id=52-重点题目及出错的题目等>5.2 重点题目及出错的题目等</h2><h3 id=225-用队列实现栈httpsleetcodecnproblemsimplement-stack-using-queues><a href=https://leetcode.cn/problems/implement-stack-using-queues/>225. 用队列实现栈</a></h3><p>1.两个队列实现栈， 其中一个队列用作暂存，当数据进来时，将另一个队列的poll到现在的队列，之后再交换。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>push</span>(<span style=color:#8be9fd>int</span> x) {
</span></span><span style=display:flex><span>    queue2.<span style=color:#50fa7b>offer</span>(x);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>queue1.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        queue2.<span style=color:#50fa7b>offer</span>(queue1.<span style=color:#50fa7b>poll</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> queuetmp <span style=color:#ff79c6>=</span> queue1;
</span></span><span style=display:flex><span>    queue1 <span style=color:#ff79c6>=</span> queue2;
</span></span><span style=display:flex><span>    queue2 <span style=color:#ff79c6>=</span> queuetmp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2.一个队列实现栈， 在pop时，将队列前的内容都重新加入到队列中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>pop</span>() {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> size <span style=color:#ff79c6>=</span> que.size();
</span></span><span style=display:flex><span>        size<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (size<span style=color:#ff79c6>--</span>) { <span style=color:#6272a4>// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            que.push(que.front());
</span></span><span style=display:flex><span>            que.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> result <span style=color:#ff79c6>=</span> que.front(); <span style=color:#6272a4>// 此时弹出的元素顺序就是栈的顺序了
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        que.pop();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=239-滑动窗口最大值httpsleetcodecnproblemssliding-window-maximum><a href=https://leetcode.cn/problems/sliding-window-maximum/>239. 滑动窗口最大值</a></h3><p>要自己创建一个单调队列，队列里只需保留可能是当前窗口最大值的数字</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>MyQueue</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//单调队列</span>
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> deque <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 同时pop之前判断队列当前是否为空。</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>poll</span>(<span style=color:#8be9fd>int</span> val) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> val <span style=color:#ff79c6>==</span> deque.<span style=color:#50fa7b>peek</span>()) {
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 这样就保持了队列里的数值是单调从大到小的了。</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>push</span>(<span style=color:#8be9fd>int</span> val) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> val <span style=color:#ff79c6>&gt;</span> deque.<span style=color:#50fa7b>getLast</span>()) {
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        deque.<span style=color:#50fa7b>add</span>(val);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>peek</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> deque.<span style=color:#50fa7b>peek</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>maxSlidingWindow</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>    MyQueue queue <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> MyQueue();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> k <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>len<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> num <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> k; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        queue.<span style=color:#50fa7b>push</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ans<span style=color:#ff79c6>[</span>num<span style=color:#ff79c6>++]</span> <span style=color:#ff79c6>=</span> queue.<span style=color:#50fa7b>peek</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> k; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        queue.<span style=color:#50fa7b>poll</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>k<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        queue.<span style=color:#50fa7b>push</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        ans<span style=color:#ff79c6>[</span>num<span style=color:#ff79c6>++]</span> <span style=color:#ff79c6>=</span> queue.<span style=color:#50fa7b>peek</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=347-前-k-个高频元素httpsleetcodecnproblemstop-k-frequent-elements><a href=https://leetcode.cn/problems/top-k-frequent-elements/>347. 前 K 个高频元素</a></h3><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率 -> map</li><li>对频率排序 -> 优先级队列</li><li>找出前K个高频元素 -> 小顶堆</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>topKFrequent</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>        HashMap<span style=color:#ff79c6>&lt;</span>Integer,Integer<span style=color:#ff79c6>&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> num : nums) {
</span></span><span style=display:flex><span>            map.<span style=color:#50fa7b>put</span>(num,map.<span style=color:#50fa7b>getOrDefault</span>(num,0)<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//        PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; o1[1]-o2[1]));</span>
</span></span><span style=display:flex><span>        PriorityQueue<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;</span> priorityQueue <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PriorityQueue<span style=color:#ff79c6>&lt;&gt;</span>(<span style=color:#ff79c6>new</span> Comparator<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;</span>() {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//小顶堆</span>
</span></span><span style=display:flex><span>            @Override
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>compare</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> o1, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> o2) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> Integer.<span style=color:#50fa7b>compare</span>(o1<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>,o2<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (Map.<span style=color:#50fa7b>Entry</span><span style=color:#ff79c6>&lt;</span>Integer, Integer<span style=color:#ff79c6>&gt;</span> entry : map.<span style=color:#50fa7b>entrySet</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (priorityQueue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&lt;</span> k) {
</span></span><span style=display:flex><span>                priorityQueue.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{entry.<span style=color:#50fa7b>getKey</span>(),entry.<span style=color:#50fa7b>getValue</span>()});
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (priorityQueue.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> entry.<span style=color:#50fa7b>getValue</span>()) {
</span></span><span style=display:flex><span>                    priorityQueue.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>                    priorityQueue.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{entry.<span style=color:#50fa7b>getKey</span>(), entry.<span style=color:#50fa7b>getValue</span>()});
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>k<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> k<span style=color:#ff79c6>-</span>1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> priorityQueue.<span style=color:#50fa7b>poll</span>()<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h1 id=6二叉树>6.二叉树</h1><h2 id=61-做题总结与技巧>6.1 做题总结与技巧</h2><h3 id=递归技巧>递归技巧</h3><p>这里帮助大家确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><h3 id=递归法>递归法</h3><h4 id=前序遍历><strong>前序遍历</strong></h4><ol><li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>traversal</span>(TreeNode<span style=color:#ff79c6>*</span> cur, List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> list)
</span></span></code></pre></div><ol start=2><li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (cur <span style=color:#ff79c6>==</span> NULL) <span style=color:#ff79c6>return</span>;
</span></span></code></pre></div><ol start=3><li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>list.<span style=color:#50fa7b>add</span>(cur<span style=color:#ff79c6>-&gt;</span>val);    <span style=color:#6272a4>// 中</span>
</span></span><span style=display:flex><span>traversal(cur<span style=color:#ff79c6>-&gt;</span>left, vec);  <span style=color:#6272a4>// 左</span>
</span></span><span style=display:flex><span>traversal(cur<span style=color:#ff79c6>-&gt;</span>right, vec); <span style=color:#6272a4>// 右</span>
</span></span></code></pre></div><p>完整代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>preorder</span>(TreeNode cur, List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cur <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    result.<span style=color:#50fa7b>add</span>(cur.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>    preorder(cur.<span style=color:#50fa7b>left</span>,result);
</span></span><span style=display:flex><span>    preorder(cur.<span style=color:#50fa7b>right</span>,result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=中序遍历>中序遍历</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>inorder</span>(TreeNode cur, List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cur <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    inorder(cur.<span style=color:#50fa7b>left</span>,result);
</span></span><span style=display:flex><span>    result.<span style=color:#50fa7b>add</span>(cur.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>    inorder(cur.<span style=color:#50fa7b>right</span>,result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=后序遍历>后序遍历</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>postorder</span>(TreeNode cur, List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cur <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    postorder(cur.<span style=color:#50fa7b>left</span>,result);
</span></span><span style=display:flex><span>    postorder(cur.<span style=color:#50fa7b>right</span>,result);
</span></span><span style=display:flex><span>    result.<span style=color:#50fa7b>add</span>(cur.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=迭代法>迭代法</h3><h4 id=前序遍历-1>前序遍历</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么<strong>先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子</strong>。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>preorderTraversal</span>(TreeNode root) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>TreeNode<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>    stack.<span style=color:#50fa7b>push</span>(root);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        TreeNode node <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>        result.<span style=color:#50fa7b>add</span>(node.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=后序遍历-1>后序遍历</h4><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-09_10-21-56.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>postorderTraversal</span>(TreeNode root) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>();
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>TreeNode<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>    stack.<span style=color:#50fa7b>push</span>(root);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        TreeNode node <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>        result.<span style=color:#50fa7b>add</span>(node.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Collections.<span style=color:#50fa7b>reverse</span>(result);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=中序遍历-1>中序遍历</h4><p><strong>需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>inorderTraversal</span>(TreeNode root) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>();
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>TreeNode<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>    TreeNode cur <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (cur <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> <span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (cur <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//指针来访问节点 将访问的节点放进栈   往左下访问</span>
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(cur);
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>left</span>;  <span style=color:#6272a4>//左</span>
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span>
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            result.<span style=color:#50fa7b>add</span>(cur.<span style=color:#50fa7b>val</span>);  <span style=color:#6272a4>// 中</span>
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>right</span>;    <span style=color:#6272a4>//右</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=统一迭代法>统一迭代法</h3><p>我们以中序遍历为例，在<a href=https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html>二叉树：听说递归能做的，栈也能做！ (opens new window)</a>中提到说使用栈的话，<strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p><p><strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>preorderTraversal</span>(TreeNode root) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>();
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>TreeNode<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>    stack.<span style=color:#50fa7b>push</span>(root);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        TreeNode node <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (node <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(node);
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(<span style=color:#ff79c6>null</span>);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            node <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            result.<span style=color:#50fa7b>add</span>(node.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>inorderTraversal</span>(TreeNode root) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>();
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>TreeNode<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>    stack.<span style=color:#50fa7b>push</span>(root);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        TreeNode node <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (node <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(node);
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(<span style=color:#ff79c6>null</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            node <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            result.<span style=color:#50fa7b>add</span>(node.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>postorderTraversal</span>(TreeNode root) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>();
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>TreeNode<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>    stack.<span style=color:#50fa7b>push</span>(root);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        TreeNode node <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (node <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(node);
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(<span style=color:#ff79c6>null</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) stack.<span style=color:#50fa7b>push</span>(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            node <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            result.<span style=color:#50fa7b>add</span>(node.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=层次遍历>层次遍历</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>levelOrder</span>(TreeNode root) {
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>TreeNode<span style=color:#ff79c6>&gt;</span> deque <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    deque.<span style=color:#50fa7b>offer</span>(root);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> size <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>size</span>();
</span></span><span style=display:flex><span>        List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> list <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> size; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            TreeNode node <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>            list.<span style=color:#50fa7b>add</span>(node.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) deque.<span style=color:#50fa7b>offer</span>(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) deque.<span style=color:#50fa7b>offer</span>(node.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(list);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=求最大最小深度可以用层次遍历和后序遍历>求最大最小深度可以用层次遍历和后序遍历</h3><h3 id=求深度适合用前序遍历而求高度适合用后序遍历但求根节点时均可>求深度适合用前序遍历，而求高度适合用后序遍历。但求根节点时均可</h3><h3 id=递归与回溯典型求二叉树的所有路径>递归与回溯，典型：求二叉树的所有路径</h3><h3 id=递归函数返回类型判定>递归函数返回类型判定：</h3><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（<a href=https://leetcode.cn/problems/path-sum-ii/>113. 路径总和 II</a>）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （<a href=https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html>236. 二叉树的最近公共祖先 (opens new window)</a>）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（<a href=https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE>112,路径总和</a>）</li><li>其实还有一种就是后序遍历需要根据左右递归的返回值推出中间节点的状态，这种需要有返回值，例如<a href=https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html>222.完全二叉树 (opens new window)</a>，<a href=https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html>110.平衡二叉树 (opens new window)</a></li></ul><h3 id=如果递归函数有返回值如何区分要搜索一条边还是搜索整个树呢>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</h3><p>搜索一条边的写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>if</span> (递归函数(root<span style=color:#ff79c6>-&gt;</span>left)) <span style=color:#ff79c6>return</span> ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (递归函数(root<span style=color:#ff79c6>-&gt;</span>right)) <span style=color:#ff79c6>return</span> ;
</span></span></code></pre></div><p>搜索整个树写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>left <span style=color:#ff79c6>=</span> 递归函数(root<span style=color:#ff79c6>-&gt;</span>left);  <span style=color:#6272a4>// 左
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>right <span style=color:#ff79c6>=</span> 递归函数(root<span style=color:#ff79c6>-&gt;</span>right); <span style=color:#6272a4>// 右
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>left与right的逻辑处理;         <span style=color:#6272a4>// 中 
</span></span></span></code></pre></div><p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</p><h3 id=构造二叉树>构造二叉树</h3><h3 id=要知道中序遍历下输出的二叉搜索树节点的数值是有序序列>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</h3><h3 id=遇到在二叉搜索树上求什么最值求差值之类的都要思考一下二叉搜索树可是有序的要利用好这一特点><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</strong></h3><h3 id=在递归遍历的过程中如何记录前后两个指针24-二叉搜索树的最小绝对差httpsprogrammercarlcom0530二叉搜索树的最小绝对差html>在递归遍历的过程中如何记录前后两个指针<a href=https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html>24. 二叉搜索树的最小绝对差</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>TreeNode pre <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>traversal</span>(TreeNode cur) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cur <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    traversal(cur.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (pre <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//处理逻辑</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    pre <span style=color:#ff79c6>=</span> cur;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    traversal(cur.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=那么二叉树如何可以自底向上查找呢>那么二叉树如何可以自底向上查找呢？</h3><p>回溯啊，二叉树回溯的过程就是从低到上。</p><p>后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。</p><h2 id=62-重点题目及出错的题目等>6.2 重点题目及出错的题目等</h2><h3 id=101-对称二叉树httpsleetcodecnproblemssymmetric-tree><a href=https://leetcode.cn/problems/symmetric-tree/>101. 对称二叉树</a></h3><p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>//递归法</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSymmetric</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> compare(root.<span style=color:#50fa7b>left</span>,root.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>compare</span>(TreeNode left, TreeNode right) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> ((left <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>||</span> (left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>)) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (left.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>!=</span> right.<span style=color:#50fa7b>val</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> outside <span style=color:#ff79c6>=</span> compare(left.<span style=color:#50fa7b>left</span>, right.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> inside <span style=color:#ff79c6>=</span> compare(left.<span style=color:#50fa7b>right</span>, right.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> isSame <span style=color:#ff79c6>=</span> outside <span style=color:#ff79c6>&amp;&amp;</span> inside;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> isSame;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>//迭代法</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSymmetric2</span>(TreeNode root) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        Queue<span style=color:#ff79c6>&lt;</span>TreeNode<span style=color:#ff79c6>&gt;</span> deque <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        deque.<span style=color:#50fa7b>offer</span>(root.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>        deque.<span style=color:#50fa7b>offer</span>(root.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>            TreeNode leftNode <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>            TreeNode rightNode <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (leftNode <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> rightNode <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (leftNode <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> rightNode <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> leftNode.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>!=</span> rightNode.<span style=color:#50fa7b>val</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>offer</span>(leftNode.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>offer</span>(rightNode.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>offer</span>(leftNode.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>offer</span>(rightNode.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=110-平衡二叉树httpsleetcodecnproblemsbalanced-binary-tree><a href=https://leetcode.cn/problems/balanced-binary-tree/>110. 平衡二叉树</a></h3><p><strong>求高度用前序遍历</strong></p><p>返回-1表示高度差大于1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isBalanced</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> getHeight(root) <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>-</span>1 <span style=color:#ff79c6>?</span> <span style=color:#ff79c6>false</span> : <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>getHeight</span>(TreeNode cur) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cur <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> leftHeight <span style=color:#ff79c6>=</span> getHeight(cur.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (leftHeight <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> rightHeight <span style=color:#ff79c6>=</span> getHeight(cur.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (rightHeight <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (Math.<span style=color:#50fa7b>abs</span>(leftHeight<span style=color:#ff79c6>-</span>rightHeight) <span style=color:#ff79c6>&gt;</span> 1) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> Math.<span style=color:#50fa7b>max</span>(leftHeight,rightHeight) <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=257-二叉树的所有路径httpsleetcodecnproblemsbinary-tree-paths><a href=https://leetcode.cn/problems/binary-tree-paths/>257. 二叉树的所有路径</a></h3><p><strong>递归中包含着回溯</strong></p><p>采用前序遍历</p><ol><li><p><strong>函数所需参数</strong>：<code>TreeNode cur, List&lt;Integer> path, List&lt;String> res</code></p></li><li><p><strong>终止条件</strong>：遇到叶子结点</p></li><li><p><strong>单层逻辑</strong></p></li></ol><p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p><pre tabindex=0><code>path.push_back(cur-&gt;val);
</code></pre><p>之后进去递归</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        traversal(cur.<span style=color:#50fa7b>left</span>,path,res);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>remove</span>(path.<span style=color:#50fa7b>size</span>()<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>      	traversal(cur.<span style=color:#50fa7b>right</span>,path,res);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>remove</span>(path.<span style=color:#50fa7b>size</span>()<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>递归完，要做回溯，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。</p><p><strong>整体代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>binaryTreePaths</span>(TreeNode root) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>    traversal(root,path,res);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>traversal</span>(TreeNode cur, List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path, List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> res) {
</span></span><span style=display:flex><span>    path.<span style=color:#50fa7b>add</span>(cur.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> cur.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        StringBuilder sb <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> StringBuilder();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> path.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>-</span> 1; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            sb.<span style=color:#50fa7b>append</span>(path.<span style=color:#50fa7b>get</span>(i));
</span></span><span style=display:flex><span>            sb.<span style=color:#50fa7b>append</span>(<span style=color:#f1fa8c>&#34;-&gt;&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        sb.<span style=color:#50fa7b>append</span>(path.<span style=color:#50fa7b>get</span>(path.<span style=color:#50fa7b>size</span>()<span style=color:#ff79c6>-</span>1));
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(sb.<span style=color:#50fa7b>toString</span>());
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        traversal(cur.<span style=color:#50fa7b>left</span>,path,res);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>remove</span>(path.<span style=color:#50fa7b>size</span>()<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        traversal(cur.<span style=color:#50fa7b>right</span>,path,res);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>remove</span>(path.<span style=color:#50fa7b>size</span>()<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=404-左叶子之和httpsleetcodecnproblemssum-of-left-leaves><a href=https://leetcode.cn/problems/sum-of-left-leaves/>404. 左叶子之和</a></h3><p><strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>if</span> (node<span style=color:#ff79c6>-&gt;</span>left <span style=color:#ff79c6>!=</span> <span style=color:#8be9fd;font-style:italic>NULL</span> <span style=color:#ff79c6>&amp;&amp;</span> node<span style=color:#ff79c6>-&gt;</span>left<span style=color:#ff79c6>-&gt;</span>left <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span> <span style=color:#ff79c6>&amp;&amp;</span> node<span style=color:#ff79c6>-&gt;</span>left<span style=color:#ff79c6>-&gt;</span>right <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) {
</span></span><span style=display:flex><span>    左叶子节点处理逻辑
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>sumOfLeftLeaves</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> leftSum <span style=color:#ff79c6>=</span> sumOfLeftLeaves(root.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>left</span>.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>left</span>.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        leftSum <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>left</span>.<span style=color:#50fa7b>val</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> rightSum <span style=color:#ff79c6>=</span> sumOfLeftLeaves(root.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> leftSum <span style=color:#ff79c6>+</span> rightSum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=26-二叉树的最近公共祖先httpsprogrammercarlcom0236二叉树的最近公共祖先html><a href=https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html>26. 二叉树的最近公共祖先</a></h3><p><strong>归纳如下三点</strong>：</p><ol><li>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</li><li><strong>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</strong></li><li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> TreeNode <span style=color:#50fa7b>lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> p <span style=color:#ff79c6>||</span> root <span style=color:#ff79c6>==</span> q <span style=color:#ff79c6>||</span> root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>    TreeNode left <span style=color:#ff79c6>=</span> lowestCommonAncestor(root.<span style=color:#50fa7b>left</span>,p,q);
</span></span><span style=display:flex><span>    TreeNode right <span style=color:#ff79c6>=</span> lowestCommonAncestor(root.<span style=color:#50fa7b>right</span>,p,q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> left;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> right;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=28-二叉搜索树的最近公共祖先httpsprogrammercarlcom0235二叉搜索树的最近公共祖先html><a href=https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html>28. 二叉搜索树的最近公共祖先</a></h3><p>由于二叉搜索树的特性，只需要查找第一个在[p,q]之间的节点就是最近公共祖先，所以本题不需要遍历全部节点，当找到结果时即可返回。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 递归法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param root
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param p
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param q
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> TreeNode <span style=color:#50fa7b>lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&lt;</span> p.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&lt;</span> q.<span style=color:#50fa7b>val</span>) {
</span></span><span style=display:flex><span>        TreeNode right <span style=color:#ff79c6>=</span> lowestCommonAncestor(root.<span style=color:#50fa7b>right</span>, p, q);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (right <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> right;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&gt;</span> p.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&gt;</span> q.<span style=color:#50fa7b>val</span>) {
</span></span><span style=display:flex><span>        TreeNode left <span style=color:#ff79c6>=</span> lowestCommonAncestor(root.<span style=color:#50fa7b>left</span>, p, q);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> left;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 迭代法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param root
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param p
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param q
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> TreeNode <span style=color:#50fa7b>lowestCommonAncestor2</span>(TreeNode root, TreeNode p, TreeNode q) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&gt;</span> p.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&gt;</span> q.<span style=color:#50fa7b>val</span>) {
</span></span><span style=display:flex><span>            root <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>left</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&lt;</span> p.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&lt;</span> q.<span style=color:#50fa7b>val</span>) {
</span></span><span style=display:flex><span>            root <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=30-删除二叉搜索树中的节点httpsprogrammercarlcom0450删除二叉搜索树中的节点html><a href=https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html>30. 删除二叉搜索树中的节点</a></h3><p>这里就把二叉搜索树中删除节点遇到的情况都搞清楚。</p><p>有以下五种情况：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> TreeNode <span style=color:#50fa7b>deleteNode</span>(TreeNode root, <span style=color:#8be9fd>int</span> key) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>==</span> key) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> root.<span style=color:#50fa7b>left</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> root.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> root.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            TreeNode node <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (node.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                node <span style=color:#ff79c6>=</span> node.<span style=color:#50fa7b>left</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            node.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>left</span>;
</span></span><span style=display:flex><span>            root <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&gt;</span> key) {
</span></span><span style=display:flex><span>        root.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>=</span> deleteNode(root.<span style=color:#50fa7b>left</span>,key);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&lt;</span> key) {
</span></span><span style=display:flex><span>        root.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>=</span> deleteNode(root.<span style=color:#50fa7b>right</span>,key);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=31-修剪二叉搜索树httpsprogrammercarlcom0669修剪二叉搜索树html><a href=https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html>31. 修剪二叉搜索树</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> TreeNode <span style=color:#50fa7b>trimBST</span>(TreeNode root, <span style=color:#8be9fd>int</span> low, <span style=color:#8be9fd>int</span> high) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&lt;</span> low) {
</span></span><span style=display:flex><span>        TreeNode right <span style=color:#ff79c6>=</span> trimBST(root.<span style=color:#50fa7b>right</span>, low, high);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> right;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&gt;</span> high) {
</span></span><span style=display:flex><span>        TreeNode left <span style=color:#ff79c6>=</span> trimBST(root.<span style=color:#50fa7b>left</span>, low, high);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> left;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    root.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>=</span> trimBST(root.<span style=color:#50fa7b>left</span>,low,high);
</span></span><span style=display:flex><span>    root.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>=</span> trimBST(root.<span style=color:#50fa7b>right</span>,low,high);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=7回溯>7.回溯</h1><h2 id=71-做题总结与技巧>7.1 做题总结与技巧</h2><h3 id=回溯法一般可以解决如下几种问题>回溯法，一般可以解决如下几种问题：</h3><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h3 id=组合是不强调元素顺序的排列是强调元素顺序><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</h3><h3 id=回溯的理解>回溯的理解</h3><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h3 id=回溯法模板>回溯法模板</h3><ul><li>回溯函数模板返回值以及参数</li></ul><p>在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。</p><p>回溯算法中函数返回值一般为void。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p><p>回溯函数伪代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>void backtracking(参数)
</span></span></code></pre></div><ul><li>回溯函数终止条件</li></ul><p>既然是树形结构，那么我们在讲解<a href=https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html>二叉树的递归 (opens new window)</a>的时候，就知道遍历树形结构一定要有终止条件。</p><p>所以回溯也有要终止条件。</p><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (终止条件) {
</span></span><span style=display:flex><span>    存放结果;
</span></span><span style=display:flex><span>    return;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>回溯搜索的遍历过程</li></ul><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-10_10-46-36.png alt></p><p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p><p>回溯函数遍历过程伪代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
</span></span><span style=display:flex><span>    处理节点;
</span></span><span style=display:flex><span>    backtracking(路径，选择列表); // 递归
</span></span><span style=display:flex><span>    回溯，撤销处理结果
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>backtracking这里自己调用自己，实现递归。</p><p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p><strong>回溯算法模板框架如下：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>void backtracking(参数) {
</span></span><span style=display:flex><span>    if (终止条件) {
</span></span><span style=display:flex><span>        存放结果;
</span></span><span style=display:flex><span>        return;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
</span></span><span style=display:flex><span>        处理节点;
</span></span><span style=display:flex><span>        backtracking(路径，选择列表); // 递归
</span></span><span style=display:flex><span>        回溯，撤销处理结果
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=对于组合问题什么时候需要startindex呢><strong>对于组合问题，什么时候需要startIndex呢？</strong></h3><p>我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：<a href=https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html>77.组合 (opens new window)</a>，<a href=https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html>216.组合总和III (opens new window)</a>。</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href=https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html>17.电话号码的字母组合(opens new window)</a></p><p><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我在讲解排列的时候会重点介绍</strong>。</p><h3 id=对于元素能够重复取的问题>对于元素能够重复取的问题：</h3><p>在<a href=https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html>2. 组合问题</a>元素只能取一次，所以<code>backtracking(candidates,target-candidates[i],i+1);</code>中index要传<code>i+1</code>来防止元素重复</p><p>在<a href=https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html>7. 组合总和</a>元素能重复取，所以<code>backtracking(candidates,target-candidates[i],i);</code>中index要传<code>i</code>来能够重复取元素</p><h3 id=树层去重与树枝去重重点>树层去重与树枝去重(重点！！！)</h3><h4 id=树层去重和树枝去重>树层去重和树枝去重</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
</span></span><span style=display:flex><span>used[i - 1] == false，说明同一树层candidates[i - 1]使用过
</span></span></code></pre></div><p><strong>树层去重：</strong><a href=https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html>8. 组合总和II</a> <a href=https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html>13. 子集II</a> 集合里面有了重复元素，求无序的集合和子集时要去重</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> candidates[i] <span style=color:#ff79c6>==</span> candidates[i <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>&amp;&amp;</span> used[i <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>false</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h4 id=去重需要先排序>去重需要先排序！！！！！</h4><h4 id=遇到无法排序的怎么办14-递增子序列httpsprogrammercarlcom0491递增子序列html在每层用set来去重>遇到无法排序的怎么办？（<a href=https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html>14. 递增子序列</a>），在每层用set来去重。</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> startIndex) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (path.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 1) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    HashSet<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> set <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startIndex; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (path.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> path.<span style=color:#50fa7b>getLast</span>() <span style=color:#ff79c6>&gt;</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>||</span> set.<span style=color:#50fa7b>contains</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>add</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        set.<span style=color:#50fa7b>add</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        backtracking(nums,i<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=如果把-子集问题组合问题分割问题都抽象为一棵树的话那么组合问题和分割问题都是收集树的叶子节点而子集问题是找树的所有节点>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></h3><p><strong>所以子集问题不需要在<code>if(判断逻辑)</code>中<code>return</code>，而组合问题、分割问题需要。</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p><h3 id=子集问题组合问题分割问题是无序的取过的元素不会重复取写回溯算法的时候for就要从startindex开始而不是从0开始重点>子集问题、组合问题、分割问题是无序的，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！（重点！！！！）</h3><h3 id=排列问题是有序的取过的还可以再取就不用使用startindex了但排列问题需要一个used数组标记已经选择的元素>排列问题是有序的，取过的还可以再取，就不用使用startIndex了，但排列问题需要一个used数组，标记已经选择的元素。</h3><h4 id=排列问题的不同>排列问题的不同：</h4><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul><h3 id=一般来说组合问题和排列问题是在树形结构的叶子节点上收集结果而子集问题就是取树上所有节点的结果><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</h3><h2 id=72-重点题目及出错的题目等>7.2 重点题目及出错的题目等</h2><h3 id=2-组合问题httpsprogrammercarlcom0077组合html><a href=https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html>2. 组合问题</a></h3><h4 id=初始>初始</h4><p><strong>startIndex 就是防止出现重复的组合</strong>。</p><p>从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是startIndex。</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-10_11-02-17.png alt></p><p>所以需要startIndex来记录下一层递归，搜索的起始位置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>LinkedList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path<span style=color:#ff79c6>=</span>  <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>combine</span>(<span style=color:#8be9fd>int</span> n, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>    backtracking(n,k,1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>int</span> n, <span style=color:#8be9fd>int</span> k, <span style=color:#8be9fd>int</span> startIndex) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (path.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>==</span> k) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startIndex; i <span style=color:#ff79c6>&lt;=</span> n; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>add</span>(i);
</span></span><span style=display:flex><span>        backtracking(n,k,i<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=剪枝优化>剪枝优化</h4><p><strong>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>。</p><p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-10_11-04-58.png alt></p><p>接下来看一下优化过程如下：</p><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>所以优化之后的for循环是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位
</span></span></code></pre></div><p>优化后整体代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>LinkedList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path<span style=color:#ff79c6>=</span>  <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>combine</span>(<span style=color:#8be9fd>int</span> n, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>    backtracking(n,k,1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>int</span> n, <span style=color:#8be9fd>int</span> k, <span style=color:#8be9fd>int</span> startIndex) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (path.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>==</span> k) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startIndex; i <span style=color:#ff79c6>&lt;=</span> n <span style=color:#ff79c6>-</span> (k <span style=color:#ff79c6>-</span> path.<span style=color:#50fa7b>size</span>()) <span style=color:#ff79c6>+</span> 1; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>add</span>(i);
</span></span><span style=display:flex><span>        backtracking(n,k,i<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=8-组合总和iihttpsprogrammercarlcom0040组合总和iihtml><a href=https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html>8. 组合总和II</a></h3><p>直接看代码随想录讲解</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>LinkedList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>combinationSum2</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> candidates, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(candidates);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> used <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>candidates.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    backtracking(candidates,target,0,used);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> candidates, <span style=color:#8be9fd>int</span> target, <span style=color:#8be9fd>int</span> startIndex, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> used) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (target <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startIndex; i <span style=color:#ff79c6>&lt;</span> candidates.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>&amp;&amp;</span> target <span style=color:#ff79c6>-</span> candidates<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>&gt;</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> candidates<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> candidates<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> used<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>false</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>add</span>(candidates<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        used<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        backtracking(candidates,target<span style=color:#ff79c6>-</span>candidates<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,i<span style=color:#ff79c6>+</span>1,used);
</span></span><span style=display:flex><span>        used<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=9-分割回文串httpsprogrammercarlcom0131分割回文串html><a href=https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html>9. 分割回文串</a></h3><ul><li>切割问题可以抽象为组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-10_14-26-09.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>LinkedList<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> path <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>partition</span>(String s) {
</span></span><span style=display:flex><span>    backtracking(s,0);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(String s, <span style=color:#8be9fd>int</span> startIndex) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (startIndex <span style=color:#ff79c6>&gt;=</span> s.<span style=color:#50fa7b>length</span>()) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startIndex; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (huiWen(s,startIndex,i)) {
</span></span><span style=display:flex><span>            path.<span style=color:#50fa7b>add</span>(s.<span style=color:#50fa7b>substring</span>(startIndex,i<span style=color:#ff79c6>+</span>1));
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        backtracking(s,i<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>huiWen</span>(String s, <span style=color:#8be9fd>int</span> left, <span style=color:#8be9fd>int</span> right) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> left,j<span style=color:#ff79c6>=</span>right; i <span style=color:#ff79c6>&lt;</span> j; i<span style=color:#ff79c6>++</span>,j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>!=</span> s.<span style=color:#50fa7b>charAt</span>(j)) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=10-复原ip地址httpsprogrammercarlcom0093复原ip地址html><a href=https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html>10. 复原IP地址</a></h3><p>也是切分问题</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>restoreIpAddresses</span>(String s) {
</span></span><span style=display:flex><span>    backtracking(<span style=color:#ff79c6>new</span> StringBuilder(s),0,0);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param sb
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param startIndex
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param pointNum  记录加点的数量
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(StringBuilder sb, <span style=color:#8be9fd>int</span> startIndex, <span style=color:#8be9fd>int</span> pointNum) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (pointNum <span style=color:#ff79c6>==</span> 3) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (Valid(sb, startIndex, sb.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>            res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> String(sb));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startIndex; i <span style=color:#ff79c6>&lt;</span> sb.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (Valid(sb,startIndex,i)) {
</span></span><span style=display:flex><span>            pointNum<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            sb.<span style=color:#50fa7b>insert</span>(i<span style=color:#ff79c6>+</span>1,<span style=color:#f1fa8c>&#39;.&#39;</span>);
</span></span><span style=display:flex><span>            backtracking(sb,i<span style=color:#ff79c6>+</span>2,pointNum);
</span></span><span style=display:flex><span>            sb.<span style=color:#50fa7b>deleteCharAt</span>(i<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>            pointNum<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 段位以0为开头的数字不合法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 段位里有非正整数字符不合法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 段位如果大于255了不合法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param sb
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param start
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param end
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>Valid</span>(StringBuilder sb, <span style=color:#8be9fd>int</span> start, <span style=color:#8be9fd>int</span> end) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (start <span style=color:#ff79c6>&gt;</span> end) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (sb.<span style=color:#50fa7b>charAt</span>(start) <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;0&#39;</span> <span style=color:#ff79c6>&amp;&amp;</span> start <span style=color:#ff79c6>!=</span> end) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> num <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> start; i <span style=color:#ff79c6>&lt;=</span> end; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (sb.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>&gt;</span> <span style=color:#f1fa8c>&#39;9&#39;</span> <span style=color:#ff79c6>||</span> sb.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>&lt;</span> <span style=color:#f1fa8c>&#39;0&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        num <span style=color:#ff79c6>=</span> num <span style=color:#ff79c6>*</span> 10 <span style=color:#ff79c6>+</span> sb.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;0&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (num <span style=color:#ff79c6>&gt;</span> 255) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=14-递增子序列httpsprogrammercarlcom0491递增子序列html><a href=https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html>14. 递增子序列</a></h3><p><strong>遇到无法排序的怎么办？</strong></p><p><strong>在每层用set来去重。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>LinkedList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>findSubsequences</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    backtracking(nums,0);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> startIndex) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (path.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 1) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    HashSet<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> set <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> startIndex; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (path.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> path.<span style=color:#50fa7b>getLast</span>() <span style=color:#ff79c6>&gt;</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>||</span> set.<span style=color:#50fa7b>contains</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>add</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        set.<span style=color:#50fa7b>add</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        backtracking(nums,i<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=15-全排列httpsprogrammercarlcom0046全排列html><a href=https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html>15. 全排列</a></h3><p>处理排列问题就不用使用startIndex了。</p><p>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-10_19-16-39.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>LinkedList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>permute</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> used <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    backtracking(nums,used);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> used) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> path.<span style=color:#50fa7b>size</span>()) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (used<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>true</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        used<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>add</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        backtracking(nums,used);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>        used<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=19-重新安排行程httpsprogrammercarlcom0332重新安排行程html><a href=https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html>19. 重新安排行程</a></h3><p>hard题</p><p><strong>这道题目有几个难点：</strong></p><ol><li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环 <code>key为起点，value是有序的终点的列表Map&lt;String, Map&lt;String, Integer>> map;，其中value是航班次数，如大于0则代表该机场没飞过</code></li><li>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？ <code>Map&lt;String, Map&lt;String, Integer>> map;</code></li><li>使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？ <code>if(res.size() == ticketNum + 1){return true;}</code></li><li>搜索的过程中，如何遍历一个机场所对应的所有机场。<code>在Map里取出当前的机场所能飞的机场</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> Deque<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> res;
</span></span><span style=display:flex><span><span style=color:#6272a4>//key为起点，value是有序的终点的列表</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> Map<span style=color:#ff79c6>&lt;</span>String, Map<span style=color:#ff79c6>&lt;</span>String, Integer<span style=color:#ff79c6>&gt;&gt;</span> map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>backTracking</span>(<span style=color:#8be9fd>int</span> ticketNum){
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(res.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>==</span> ticketNum <span style=color:#ff79c6>+</span> 1){
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    String last <span style=color:#ff79c6>=</span> res.<span style=color:#50fa7b>getLast</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(map.<span style=color:#50fa7b>containsKey</span>(last)){<span style=color:#6272a4>//防止出现null</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span>(Map.<span style=color:#50fa7b>Entry</span><span style=color:#ff79c6>&lt;</span>String, Integer<span style=color:#ff79c6>&gt;</span> target : map.<span style=color:#50fa7b>get</span>(last).<span style=color:#50fa7b>entrySet</span>()){
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> target.<span style=color:#50fa7b>getValue</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span>(count <span style=color:#ff79c6>&gt;</span> 0){ <span style=color:#6272a4>// 记录到达机场是否飞过了</span>
</span></span><span style=display:flex><span>                res.<span style=color:#50fa7b>add</span>(target.<span style=color:#50fa7b>getKey</span>());
</span></span><span style=display:flex><span>                target.<span style=color:#50fa7b>setValue</span>(count <span style=color:#ff79c6>-</span> 1);
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span>(backTracking(ticketNum)) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                res.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>                target.<span style=color:#50fa7b>setValue</span>(count);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>findItinerary</span>(List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> tickets) {
</span></span><span style=display:flex><span>    map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;</span>String, Map<span style=color:#ff79c6>&lt;</span>String, Integer<span style=color:#ff79c6>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> t : tickets){
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//将到达机场进行字典排序</span>
</span></span><span style=display:flex><span>        Map<span style=color:#ff79c6>&lt;</span>String, Integer<span style=color:#ff79c6>&gt;</span> temp;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(map.<span style=color:#50fa7b>containsKey</span>(t.<span style=color:#50fa7b>get</span>(0))){
</span></span><span style=display:flex><span>            temp <span style=color:#ff79c6>=</span> map.<span style=color:#50fa7b>get</span>(t.<span style=color:#50fa7b>get</span>(0));
</span></span><span style=display:flex><span>            temp.<span style=color:#50fa7b>put</span>(t.<span style=color:#50fa7b>get</span>(1), temp.<span style=color:#50fa7b>getOrDefault</span>(t.<span style=color:#50fa7b>get</span>(1), 0) <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>        }<span style=color:#ff79c6>else</span>{
</span></span><span style=display:flex><span>            temp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> TreeMap<span style=color:#ff79c6>&lt;&gt;</span>();<span style=color:#6272a4>//升序Map</span>
</span></span><span style=display:flex><span>            temp.<span style=color:#50fa7b>put</span>(t.<span style=color:#50fa7b>get</span>(1), 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        map.<span style=color:#50fa7b>put</span>(t.<span style=color:#50fa7b>get</span>(0), temp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    res.<span style=color:#50fa7b>add</span>(<span style=color:#f1fa8c>&#34;JFK&#34;</span>);
</span></span><span style=display:flex><span>    backTracking(tickets.<span style=color:#50fa7b>size</span>());
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(res);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=20-n皇后httpsprogrammercarlcom0051n皇后html和21-解数独httpsprogrammercarlcom0037解数独html><a href=https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html>20. N皇后</a>和<a href=https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html>21. 解数独</a></h3><p>hard题</p><p>N皇后是一层for循环</p><p>解数独是两层for循环</p><p><strong>N皇后问题代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>solveNQueens</span>(<span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> chessboard <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> chessboard.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> chessboard<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            chessboard<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;.&#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    backtracking(n,0,chessboard);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>int</span> n, <span style=color:#8be9fd>int</span> row, <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> chessboard) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (row <span style=color:#ff79c6>==</span> n) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(Array2List(chessboard));
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> col <span style=color:#ff79c6>=</span> 0; col <span style=color:#ff79c6>&lt;</span> n; col<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (Valid(row,col,chessboard,n)) {
</span></span><span style=display:flex><span>            chessboard<span style=color:#ff79c6>[</span>row<span style=color:#ff79c6>][</span>col<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;Q&#39;</span>;
</span></span><span style=display:flex><span>            row<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            backtracking(n,row,chessboard);
</span></span><span style=display:flex><span>            row<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>            chessboard<span style=color:#ff79c6>[</span>row<span style=color:#ff79c6>][</span>col<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;.&#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>Valid</span>(<span style=color:#8be9fd>int</span> row, <span style=color:#8be9fd>int</span> col, <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> chessboard, <span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> row; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (chessboard<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>col<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;Q&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> row <span style=color:#ff79c6>-</span> 1,j <span style=color:#ff79c6>=</span> col <span style=color:#ff79c6>-</span> 1; i <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> j <span style=color:#ff79c6>&gt;=</span> 0 ; i<span style=color:#ff79c6>--</span>,j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (chessboard<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;Q&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> row <span style=color:#ff79c6>-</span> 1,j <span style=color:#ff79c6>=</span> col <span style=color:#ff79c6>+</span> 1; i <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> j <span style=color:#ff79c6>&lt;</span> n ; i<span style=color:#ff79c6>--</span>,j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (chessboard<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;Q&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> List <span style=color:#50fa7b>Array2List</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> chessboard) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> list <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> chars : chessboard) {
</span></span><span style=display:flex><span>        list.<span style=color:#50fa7b>add</span>(String.<span style=color:#50fa7b>copyValueOf</span>(chars));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> list;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>解数独问题代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>solveSudoku</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> board) {
</span></span><span style=display:flex><span>    backtracking(board);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> board) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> board.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> board<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (board<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>!=</span> <span style=color:#f1fa8c>&#39;.&#39;</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>char</span> k <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;1&#39;</span>; k <span style=color:#ff79c6>&lt;=</span> <span style=color:#f1fa8c>&#39;9&#39;</span>; k<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (isValid(i,j,k,board)) {
</span></span><span style=display:flex><span>                    board<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> k;
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>if</span> (backtracking(board)) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>; <span style=color:#6272a4>// 如果找到合适一组立刻返回</span>
</span></span><span style=display:flex><span>                    board<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;.&#39;</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>; <span style=color:#6272a4>// 9个数都试完了，都不行，那么就返回false</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>; <span style=color:#6272a4>// 遍历完没有返回false，说明找到了合适棋盘位置了</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isValid</span>(<span style=color:#8be9fd>int</span> row, <span style=color:#8be9fd>int</span> col, <span style=color:#8be9fd>char</span> val, <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> board) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 9; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (board<span style=color:#ff79c6>[</span>row<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> val) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 9; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (board<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>col<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> val) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> (row <span style=color:#ff79c6>/</span> 3) <span style=color:#ff79c6>*</span> 3;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> y <span style=color:#ff79c6>=</span> (col <span style=color:#ff79c6>/</span> 3) <span style=color:#ff79c6>*</span> 3;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> x; i <span style=color:#ff79c6>&lt;</span> x <span style=color:#ff79c6>+</span> 3; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> y; j <span style=color:#ff79c6>&lt;</span> y <span style=color:#ff79c6>+</span> 3; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (board<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> val) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=8-动态规划>8. 动态规划</h1><h2 id=81-做题总结与技巧>8.1 做题总结与技巧</h2><h3 id=对于动态规划问题我将拆解为如下五步曲这五步都搞清楚了才能说把动态规划真的掌握了><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></h3><ol><li>确定<code>dp</code>数组（<code>dp table</code>）以及下标的含义</li><li>确定递推公式</li><li><code>dp</code>数组如何初始化</li><li>确定遍历顺序</li><li>举例推导<code>dp</code>数组</li></ol><h3 id=背包问题预览对于面试的话只需掌握0-1背包完全背包最多可以再来一个多重背包>背包问题预览(对于面试的话，只需掌握0-1背包、完全背包，最多可以再来一个多重背包)</h3><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-11_09-06-41.png alt></p><h2 id=811--0-1背包问题>8.1.1. 0-1背包问题</h2><h4 id=问题概念>问题概念</h4><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i] </code>。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><h4 id=二维数组>二维数组</h4><h4 id=确定dp数组以及下标的含义>确定dp数组以及下标的含义</h4><p>使用二维数组，<strong><code>dp[i][j]</code> 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><h4 id=确定递推公式>确定递推公式</h4><ul><li><strong>不放物品i</strong>：由<code>dp[i - 1][j]</code>推出，即背包容量为j，里面不放物品i的最大价值，此时<code>dp[i][j]</code>就是<code>dp[i - 1][j]</code>。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由<code>dp[i - 1][j - weight[i]]</code>推出，<code>dp[i - 1][j - weight[i]] </code>为背包容量为<code>j - weight[i]</code>的时候不放物品i的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i] </code>（物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>所以递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><h4 id=dp数组如何初始化>dp数组如何初始化</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>for (int j = 0 ; j &lt; weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
</span></span><span style=display:flex><span>    dp[0][j] = 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>// 正序遍历
</span></span><span style=display:flex><span>for (int j = weight[0]; j &lt;= bagweight; j++) {
</span></span><span style=display:flex><span>    dp[0][j] = value[0];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-11_09-13-12.png alt></p><h4 id=遍历顺序>遍历顺序</h4><h5 id=先遍历物品然后遍历背包重量><strong>先遍历物品，然后遍历背包重量</strong></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// weight数组的大小 就是物品个数
</span></span><span style=display:flex><span>for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品
</span></span><span style=display:flex><span>    for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量
</span></span><span style=display:flex><span>        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j];
</span></span><span style=display:flex><span>        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=先遍历背包再遍历物品也是可以的><strong>先遍历背包，再遍历物品，也是可以的！</strong></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// weight数组的大小 就是物品个数
</span></span><span style=display:flex><span>for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量
</span></span><span style=display:flex><span>    for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品
</span></span><span style=display:flex><span>        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j];
</span></span><span style=display:flex><span>        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=heading>===============================================</h4><h4 id=滚动数组>滚动数组</h4><h4 id=确定dp数组以及下标的含义-1>确定dp数组以及下标的含义</h4><p><code>dp[j]</code>表示：容量为j的背包，所背的物品价值可以最大为<code>dp[j]</code>。</p><h4 id=递推公式>递推公式</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
</span></span></code></pre></div><h4 id=初始化>初始化</h4><p>dp数组初始化的时候，都初始为0就可以了。</p><h4 id=遍历顺序-1>遍历顺序</h4><p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p><p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品
</span></span><span style=display:flex><span>    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量
</span></span><span style=display:flex><span>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=完整代码>完整代码：</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 二维数组
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param weight
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param value
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param bagSize
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>Bag0And1Problem</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> weight, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> value, <span style=color:#8be9fd>int</span> bagSize) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>weight.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>bagSize<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> weight<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> value<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>&lt;</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>weight.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>bagSize<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 滚动数组
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param weight
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param value
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param bagSize
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>Bag0And1Problem2</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> weight, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> value, <span style=color:#8be9fd>int</span> bagSize) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> bagSize; j <span style=color:#ff79c6>&gt;=</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>; j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>-</span>weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=求具体方案>求具体方案：</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 具体方案
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param weight
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param value
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param bagSize
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>Bag0And1Problem2Plus</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> weight, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> value, <span style=color:#8be9fd>int</span> bagSize) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> bagSize; j <span style=color:#ff79c6>&gt;=</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>; j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>-</span>weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 回溯求解具体方案</span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> solution <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> remainingCapacity <span style=color:#ff79c6>=</span> bagSize;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> weight.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (remainingCapacity <span style=color:#ff79c6>&gt;=</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> dp<span style=color:#ff79c6>[</span>remainingCapacity<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> dp<span style=color:#ff79c6>[</span>remainingCapacity <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            solution.<span style=color:#50fa7b>add</span>(0,(i <span style=color:#ff79c6>+</span> 1));
</span></span><span style=display:flex><span>            remainingCapacity <span style=color:#ff79c6>-=</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> solution.<span style=color:#50fa7b>size</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>print</span>(solution.<span style=color:#50fa7b>get</span>(i) <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=0-1背包几种类型>0-1背包几种类型</h3><h4 id=1求容量为j的背包最多能装多少>1.求容量为j的背包，最多能装多少。</h4><p>递推公式：<strong><code>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</code></strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> max(dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>j <span style=color:#ff79c6>-</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span></code></pre></div><h4 id=2求容量为j的背包装满有几种方法>2.求容量为j的背包，装满有几种方法。</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+=</span> dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>-</span>nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span>;
</span></span></code></pre></div><p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p><p><strong>后面我们在讲解完全背包的时候，还会用到这个递推公式！</strong></p><h4 id=3有两个维度的0-1背包17-一和零httpsprogrammercarlcom0474一和零html>3.有两个维度的0-1背包。<a href=https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html>17. 一和零</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> m; i <span style=color:#ff79c6>&gt;=</span> zeroNum; i<span style=color:#ff79c6>--</span>) { <span style=color:#6272a4>// 遍历背包容量且从后向前遍历！
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> n; j <span style=color:#ff79c6>&gt;=</span> oneNum; j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#ff79c6>=</span> max(dp[i][j], dp[i <span style=color:#ff79c6>-</span> zeroNum][j <span style=color:#ff79c6>-</span> oneNum] <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=此时我们讲解了0-1背包的多种应用>此时我们讲解了0-1背包的多种应用：</h3><ul><li><a href=https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html>纯 0 - 1 背包 (opens new window)</a>是求 给定背包容量 装满背包 的最大价值是多少。</li><li><a href=https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html>416. 分割等和子集 (opens new window)</a>是求 给定背包容量，能不能装满这个背包。</li><li><a href=https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html>1049. 最后一块石头的重量 II (opens new window)</a>是求 给定背包容量，尽可能装，最多能装多少。</li><li><a href=https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html>494. 目标和 (opens new window)</a>是求 给定背包容量，装满背包有多少种方法。</li><li><a href=https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html>17. 一和零</a>是求 给定背包容量，装满背包最多有多少个物品。</li></ul><h2 id=812--完全背包问题>8.1.2. 完全背包问题</h2><h4 id=问题概念-1>问题概念</h4><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><h4 id=二维数组-1>二维数组</h4><h5 id=先遍历物品然后遍历背包重量-1><strong>先遍历物品，然后遍历背包重量</strong></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// weight数组的大小 就是物品个数</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>size</span>(); i<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 遍历物品</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;=</span> bagweight; j<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 遍历背包容量</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>&lt;</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> max(dp<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=先遍历背包再遍历物品也是可以的-1><strong>先遍历背包，再遍历物品，也是可以的！</strong></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// weight数组的大小 就是物品个数</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;=</span> bagweight; j<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 遍历背包容量</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>size</span>(); i<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 遍历物品</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>&lt;</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> max(dp<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>注意：其中与0-1背包中的<code>dp[i][j] = max(dp[i - 1][j], dp[i-1][j - weight[i]] + value[i]);</code>不同在于完全背包的<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);</code>。</strong></p><p><strong>在01背包问题中，我们使用的是<code>dp[i-1][j - weight[i]] + value[i]</code>，即上一个物品和当前物品减去其重量的价值；而在完全背包问题中，我们使用的是<code>dp[i][j - weight[i]] + value[i]</code>，即当前物品减去其重量的价值，这允许我们多次选择当前物品。</strong></p><h4 id=heading-1>===============================================</h4><h4 id=滚动数组-1>滚动数组</h4><h4 id=遍历顺序-2>遍历顺序</h4><h5 id=完全背包的物品是可以添加多次的所以要从小到大去遍历>完全背包的物品是可以添加多次的，所以要从小到大去遍历。</h5><h5 id=先遍历物品再遍历背包---组合数>先遍历物品，再遍历背包 ->组合数</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#6272a4>// 先遍历物品，再遍历背包
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> weight.size(); i<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 遍历物品
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> weight[i]; j <span style=color:#ff79c6>&lt;=</span> bagWeight ; j<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 遍历背包容量
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        dp[j] <span style=color:#ff79c6>=</span> max(dp[j], dp[j <span style=color:#ff79c6>-</span> weight[i]] <span style=color:#ff79c6>+</span> value[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。</p><h5 id=先遍历背包再遍历物品---排列数>先遍历背包，再遍历物品 ->排列数</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#6272a4>// 先遍历背包，再遍历物品
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; j <span style=color:#ff79c6>&lt;=</span> bagWeight; j<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 遍历背包容量
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> weight.size(); i<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 遍历物品
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>-</span> weight[i] <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>0</span>) dp[j] <span style=color:#ff79c6>=</span> max(dp[j], dp[j <span style=color:#ff79c6>-</span> weight[i]] <span style=color:#ff79c6>+</span> value[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=完整代码-1>完整代码：</h4><h5 id=先遍历物品再遍历背包---组合数版本>（先遍历物品，再遍历背包 ->组合数）版本</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 二维数组
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param weight
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param value
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param bagSize
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>BagAllProblem</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> weight, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> value, <span style=color:#8be9fd>int</span> bagSize) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>weight.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>bagSize<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> weight<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> value<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>&lt;</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>weight.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>bagSize<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 滚动数组
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param weight
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param value
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param bagSize
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>BagAllProblem2</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> weight, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> value, <span style=color:#8be9fd>int</span> bagSize) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>-</span>weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=先遍历背包再遍历物品---排列数版本>（先遍历背包，再遍历物品 ->排列数）版本</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 二维数组  （先遍历背包，再遍历物品  -&gt;排列数）版本
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param weight
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param value
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param bagSize
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>BagAllProblem3</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> weight, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> value, <span style=color:#8be9fd>int</span> bagSize) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>weight.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>bagSize<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> weight<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> value<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;=</span> 0) dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>weight.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>bagSize<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 滚动数组  （先遍历背包，再遍历物品  -&gt;排列数）版本
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param weight
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param value
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param bagSize
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>BagAllProblem4</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> weight, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> value, <span style=color:#8be9fd>int</span> bagSize) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;=</span> 0) dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>-</span>weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=求具体方案-1>求具体方案：</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 求具体方案
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param weight
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param value
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param bagSize
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>BagAllProblem2Plus</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> weight, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> value, <span style=color:#8be9fd>int</span> bagSize) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> choices <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>weight.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>bagSize <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>]</span>; <span style=color:#6272a4>// 记录每种物品放入背包的数量</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> weight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>; j <span style=color:#ff79c6>&lt;=</span> bagSize; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> dp<span style=color:#ff79c6>[</span>j <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>j <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                choices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> choices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> 1; <span style=color:#6272a4>// 记录放入数量</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 回溯求解具体方案</span>
</span></span><span style=display:flex><span>    StringBuilder solution <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> StringBuilder();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> remainingCapacity <span style=color:#ff79c6>=</span> bagSize;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> weight.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (remainingCapacity <span style=color:#ff79c6>&gt;=</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> dp<span style=color:#ff79c6>[</span>remainingCapacity<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> dp<span style=color:#ff79c6>[</span>remainingCapacity <span style=color:#ff79c6>-</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>+</span> value<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> choices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>remainingCapacity<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            solution.<span style=color:#50fa7b>insert</span>(0, <span style=color:#f1fa8c>&#34;物品&#34;</span> <span style=color:#ff79c6>+</span> (i <span style=color:#ff79c6>+</span> 1) <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34;数量&#34;</span> <span style=color:#ff79c6>+</span> count <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34; &#34;</span>);
</span></span><span style=display:flex><span>            remainingCapacity <span style=color:#ff79c6>-=</span> count <span style=color:#ff79c6>*</span> weight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>println</span>(solution);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>bagSize<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=注意对于纯完全背包问题其for循环的先后循环是可以颠倒的但如果题目稍稍有点变化就会体现在遍历顺序上>注意：**对于纯完全背包问题，其for循环的先后循环是可以颠倒的！**但如果题目稍稍有点变化，就会体现在遍历顺序上。</h4><p>如果问装满背包有几种方式的话？ 那么两个for循环的先后顺序就有很大区别了，而leetcode上的题目都是这种稍有变化的类型。</p><h4 id=遍历顺序与--求组合数排列数--的关系>遍历顺序与 求组合数、排列数 的关系</h4><h5 id=如果求组合数就是外层for循环遍历物品内层for遍历背包>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</h5><h5 id=如果求排列数就是外层for遍历背包内层for循环遍历物品>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</h5><h3 id=题目中要求个数等一般可用动态规划而求所有组合则用回溯>题目中要求个数等一般可用动态规划，而求所有组合则用回溯。</h3><p>例如：<a href=https://leetcode.cn/problems/combination-sum-iv/>377. 组合总和 Ⅳ</a>和<a href=https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html>4. 组合总和III</a></p><h3 id=背包问题中求组合数求排列数求最小数总结>背包问题中求组合数、求排列数、求最小数总结</h3><p>求组合数：<a href=https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html>动态规划：518.零钱兑换II (opens new window)</a>求排列数：<a href=https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html>动态规划：377. 组合总和 Ⅳ (opens new window)</a>、<a href=https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html>动态规划：70. 爬楼梯进阶版（完全背包） (opens new window)</a>、<a href=https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html>26. 单词拆分</a>求最小数：<a href=https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html>动态规划：322. 零钱兑换 (opens new window)</a>、<a href=https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html>动态规划：279.完全平方数</a></p><h3 id=背包问题总结篇httpsprogrammercarlcom背包总结篇html><a href=https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html>背包问题总结篇</a></h3><h2 id=813--打家劫舍问题系列>8.1.3. 打家劫舍问题系列</h2><p><strong>劫舍系列简单来说就是 数组上连续元素二选一，成环之后连续元素二选一，在树上连续元素二选一，所能得到的最大价值</strong>。</p><h4 id=打家劫舍httpsprogrammercarlcom0198打家劫舍html><a href=https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html>打家劫舍</a></h4><h5 id=问题概述>问题概述：</h5><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><h5 id=dp定义>dp定义：</h5><p><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong>。</p><h5 id=递推公式-1>递推公式：</h5><p>如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p><p>如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p><p>然后dp[i]取最大值，即<code>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</code></p><h5 id=初始化-1>初始化：</h5><p>从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p><p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：<code>dp[1] = max(nums[0], nums[1]);</code></p><h5 id=遍历顺序-3>遍历顺序：</h5><p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>rob</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> 1) <span style=color:#ff79c6>return</span> nums<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(nums<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>,nums<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 2; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=打家劫舍iihttpsprogrammercarlcom0213打家劫舍iihtml><a href=https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html>打家劫舍II</a></h4><h5 id=问题概述-1>问题概述：</h5><p>所有的房屋都 <strong>围成一圈</strong></p><h5 id=思路>思路：</h5><p>对于一个数组，成环的话需要考虑的情况：</p><ul><li>情况一：考虑包含首元素，不包含尾元素</li></ul><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-11_21-05-32.png alt></p><ul><li>情况二：考虑包含尾元素，不包含首元素</li></ul><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-11_21-05-37.png alt></p><p>将<a href=https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html>打家劫舍</a>的代码抽离出来，用来处理情况一和情况二</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> result1 <span style=color:#ff79c6>=</span> robRange(nums, 0, nums.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>-</span> 2); <span style=color:#6272a4>// 情况一</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> result2 <span style=color:#ff79c6>=</span> robRange(nums, 1, nums.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>-</span> 1); <span style=color:#6272a4>// 情况二</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>rob</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> 0) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> 1) <span style=color:#ff79c6>return</span> nums<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> result1 <span style=color:#ff79c6>=</span> robRange(nums,0,nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>2);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> result2 <span style=color:#ff79c6>=</span> robRange(nums,1,nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> Math.<span style=color:#50fa7b>max</span>(result1,result2);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>robRange</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> left, <span style=color:#8be9fd>int</span> right) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> right) <span style=color:#ff79c6>return</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>,nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> left<span style=color:#ff79c6>+</span>2; i <span style=color:#ff79c6>&lt;=</span> right; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=打家劫舍iiihttpsprogrammercarlcom0337打家劫舍iiihtml><a href=https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html>打家劫舍III</a></h4><h5 id=问题概述-2>问题概述：</h5><p>这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“<strong>这个地方的所有房屋的排列类似于一棵二叉树</strong>”。<strong>如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</strong></p><h5 id=树形dp的入门题目>树形dp的入门题目</h5><p><strong>这道题目算是树形dp的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解</strong>。</p><h5 id=以递归三部曲为框架其中融合动规五部曲的内容><strong>以递归三部曲为框架，其中融合动规五部曲的内容</strong></h5><ul><li>确定递归函数的参数和返回值</li></ul><p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p><p>参数为当前节点，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>robTree</span>(TreeNode cur) {
</span></span></code></pre></div><p>其实这里的返回数组就是dp数组。</p><p>所以<strong>dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</strong></p><p><strong>所以本题dp数组就是一个长度为2的数组！</strong></p><ul><li>确定终止条件</li></ul><p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (cur <span style=color:#ff79c6>==</span> NULL) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{0,0};
</span></span></code></pre></div><p>这也相当于dp数组的初始化。</p><ul><li>确定遍历顺序</li></ul><p>首先明确的是使用<strong>后序遍历</strong>。 因为要通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#6272a4>// 下标0：不偷，下标1：偷
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span>[] left <span style=color:#ff79c6>=</span> robTree(cur<span style=color:#ff79c6>-&gt;</span>left); <span style=color:#6272a4>// 左
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span>[] right <span style=color:#ff79c6>=</span> robTree(cur<span style=color:#ff79c6>-&gt;</span>right); <span style=color:#6272a4>// 右
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 中
</span></span></span></code></pre></div><ul><li>确定单层递归的逻辑</li></ul><p>如果是偷当前节点，那么左右孩子就不能偷，<code>val1 = cur->val + left[0] + right[0];</code></p><p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：<code>val2 = max(left[0], left[1]) + max(right[0], right[1]);</code></p><p>最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p><p>代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> left <span style=color:#ff79c6>=</span> robTree(cur<span style=color:#ff79c6>-&gt;</span>left); <span style=color:#6272a4>// 左</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> right <span style=color:#ff79c6>=</span> robTree(cur<span style=color:#ff79c6>-&gt;</span>right); <span style=color:#6272a4>// 右</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 偷cur</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> val1 <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>+</span> left<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> right<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span><span style=color:#6272a4>// 不偷cur</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> val2 <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(left<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>, left<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>+</span> Math.<span style=color:#50fa7b>max</span>(right<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>, right<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{val2, val1};
</span></span></code></pre></div><p><strong>最后头结点就是 取下标0 和 下标1的最大值就是偷得的最大金钱</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>rob</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> tree <span style=color:#ff79c6>=</span> robTree(root);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> Math.<span style=color:#50fa7b>max</span>(tree<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>, tree<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>robTree</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{0,0};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> left <span style=color:#ff79c6>=</span> robTree(root.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> right <span style=color:#ff79c6>=</span> robTree(root.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> val1 <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>+</span> left<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> right<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> val2 <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(left<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>,left<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>+</span> Math.<span style=color:#50fa7b>max</span>(right<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>, right<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{val2,val1};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=814---买卖股票问题系列>8.1.4. 买卖股票问题系列</h2><h3 id=买卖股票的最佳时机httpsprogrammercarlcom0121买卖股票的最佳时机html><a href=https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html>买卖股票的最佳时机</a></h3><p>股票只能买卖一次。</p><h4 id=dp定义-1>dp定义：</h4><p><code>dp[i][0] </code>表示第i天持有股票所得最多现金</p><p><code>dp[i][1] </code>表示第i天不持有股票所得最多现金</p><p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p><h4 id=递推公式-2>递推公式</h4><p>如果第i天持有股票即<code>dp[i][0]</code>， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1][0]</code></li><li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：<code>-prices[i]</code></li></ul><p>那么<code>dp[i][0]</code>应该选所得现金最大的，所以<code>dp[i][0] = max(dp[i - 1][0], -prices[i]);</code></p><p>如果第i天不持有股票即<code>dp[i][1]</code>， 也可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code></li><li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：<code>prices[i] + dp[i - 1][0]</code></li></ul><p>同样<code>dp[i][1]</code>取最大的，<code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</code></p><h4 id=初始化-2>初始化</h4><p><code>dp[0][0]</code>表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以<code>dp[0][0] -= prices[0];</code></p><p><code>dp[0][1]</code>表示第0天不持有股票，不持有股票那么现金就是0，所以<code>dp[0][1] = 0;</code></p><h4 id=遍历顺序-4>遍历顺序</h4><p>从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * DP方法解决
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param prices
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>maxProfit</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> prices) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>prices.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>prices<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> prices.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>,<span style=color:#ff79c6>-</span>prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]+</span>prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>prices.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=买卖股票的最佳时机iihttpsprogrammercarlcom0122买卖股票的最佳时机ii动态规划html><a href=https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html>买卖股票的最佳时机II</a></h3><p>本题和<a href=https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html>121. 买卖股票的最佳时机 (opens new window)</a>的唯一区别是本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）</p><p>如果第i天持有股票即<code>dp[i][0]</code>， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1</code>][0]</li><li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：<code>dp[i - 1][1] - prices[i]</code></li></ul><p>再来看看如果第i天不持有股票即<code>dp[i][1]</code>的情况， 依然可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1</code>][1]</li><li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：<code>prices[i] + dp[i - 1</code>][0]</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span></code></pre></div><h3 id=买卖股票的最佳时机iiihttpsprogrammercarlcom0123买卖股票的最佳时机iiihtml><a href=https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html>买卖股票的最佳时机III</a></h3><p>关键在于<strong>至多买卖两次</strong>，这意味着可以买卖一次，可以买卖两次，也可以不买卖。</p><ul><li>确定dp数组以及下标的含义</li></ul><p>一天一共就有五个状态，</p><ol><li>没有操作 （其实我们也可以不设置这个状态）</li><li>第一次持有股票</li><li>第一次不持有股票</li><li>第二次持有股票</li><li>第二次不持有股票</li></ol><p><code>dp[i][j]</code>中 i表示第i天，j为 [0 - 4] 五个状态，<code>dp[i][j]</code>表示第i天状态j所剩最大现金。</p><ul><li>确定递推公式</li></ul><p>达到<code>dp[i][1]</code>状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么<code>dp[i][1] = dp[i-1][0] - prices[i]</code></li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：<code>dp[i][1] = dp[i - 1</code>][1]</li></ul><p>那么<code>dp[i][1]</code>究竟选 <code>dp[i-1][0] - prices[i]</code>，还是<code>dp[i - 1][1]</code>呢？</p><p>一定是选最大的，所以 <code>dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);</code></p><p>同理<code>dp[i][2]</code>也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么<code>dp[i][2] = dp[i - 1][1] + prices[i]</code></li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：<code>dp[i][2] = dp[i - 1][2]</code></li></ul><p>所以<code>dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code></p><p>同理可推出剩下状态部分：</p><p><code>dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</code></p><p><code>dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</code></p><ul><li>dp数组如何初始化</li></ul><p>第0天做第一次买入的操作，<code>dp[0][1] = -prices[0];</code></p><p>第二次买入操作，初始化为：<code>dp[0][3] = -prices[0];</code></p><ul><li>确定遍历顺序</li></ul><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>4<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>4<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span></code></pre></div><h3 id=买卖股票的最佳时机ivhttpsprogrammercarlcom0188买卖股票的最佳时机ivhtml><a href=https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html>买卖股票的最佳时机IV</a></h3><p><strong>最多可以完成 <code>k</code> 笔交易</strong></p><p><strong>本题和<a href=https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html>动态规划：123.买卖股票的最佳时机III (opens new window)</a>最大的区别就是这里要类比j为奇数是买，偶数是卖的状态</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>maxProfit</span>(<span style=color:#8be9fd>int</span> k, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> prices) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>prices.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>*</span>k<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> 2<span style=color:#ff79c6>*</span>k<span style=color:#ff79c6>+</span>1; i<span style=color:#ff79c6>=</span>i<span style=color:#ff79c6>+</span>2) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>prices<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> prices.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;</span> 2<span style=color:#ff79c6>*</span>k; j<span style=color:#ff79c6>=</span>j<span style=color:#ff79c6>+</span>2) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]-</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>prices.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>*</span>k<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=最佳买卖股票时机含冷冻期httpsprogrammercarlcom0309最佳买卖股票时机含冷冻期html><a href=https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html>最佳买卖股票时机含冷冻期</a></h3><p>相对于<a href=https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html>动态规划：122.买卖股票的最佳时机II (opens new window)</a>，本题加上了一个冷冻期</p><ul><li>确定dp数组以及下标的含义</li></ul><p><code>dp[i][j]</code>，第i天状态为j，所剩的最多现金为<code>dp[i][j]</code>。</p><p>具体可以区分出如下四个状态：</p><ul><li>状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li><li>不持有股票状态，这里就有两种卖出股票状态<ul><li>状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li><li>状态三：今天卖出股票</li></ul></li><li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li></ul><p>因为本题我们有冷冻期，而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。</p><ul><li>确定递推公式</li></ul><p><strong>达到买入股票状态</strong>（状态一）即：<code>dp[i][0]</code>，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），<code>dp[i][0] = dp[i - 1][0]</code></li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），<code>dp[i - 1][3] - prices[i]</code></li><li>前一天是保持卖出股票的状态（状态二），<code>dp[i - 1][1] - prices[i]</code></li></ul></li></ul><p>那么<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);</code></p><p><strong>达到保持卖出股票状态</strong>（状态二）即：<code>dp[i][1]</code>，有两个具体操作：</p><ul><li>操作一：前一天就是状态二</li><li>操作二：前一天是冷冻期（状态四）</li></ul><p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);</code></p><p><strong>达到今天就卖出股票状态</strong>（状态三），即：<code>dp[i][2] </code>，只有一个操作：</p><p>昨天一定是持有股票状态（状态一），今天卖出</p><p>即：<code>dp[i][2] = dp[i - 1][0] + prices[i];</code></p><p><strong>达到冷冻期状态</strong>（状态四），即：<code>dp[i][3]</code>，只有一个操作：</p><p>昨天卖出了股票（状态三）</p><p><code>dp[i][3] = dp[i - 1][2];</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>, Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span>;
</span></span></code></pre></div><ul><li>初始化</li></ul><p>如果是持有股票状态（状态一）那么：<code>dp[0][0] = -prices[0]</code>，一定是当天买入股票。</p><p>其余状态都初始化为0；</p><ul><li>确定遍历顺序</li></ul><p>从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>maxProfit</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> prices) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>prices.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>4<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-=</span> prices<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>; <span style=color:#6272a4>// 持股票</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> prices.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>, Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> prices<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>prices.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>,Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>prices.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>2<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>prices.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>3<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=买卖股票的最佳时机含手续费httpsprogrammercarlcom0714买卖股票的最佳时机含手续费动态规划html><a href=https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html>买卖股票的最佳时机含手续费</a></h3><p>相对于<a href=https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html>动态规划：122.买卖股票的最佳时机II (opens new window)</a>，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。</p><h3 id=股票问题总结篇httpsprogrammercarlcom动态规划-股票问题总结篇html><a href=https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html>股票问题总结篇</a></h3><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-12_10-30-01.png alt></p><h2 id=815---子序列问题>8.1.5. 子序列问题</h2><h3 id=要联动起来才能理解递增子序列怎么求递增连续子序列又要怎么求概括来说不连续递增子序列的跟前0-到-i-个状态有关连续递增的子序列只跟前一个状态有关><strong>要联动起来，才能理解递增子序列怎么求，递增连续子序列又要怎么求</strong>。概括来说：不连续递增子序列的跟前0 到 i 个状态有关，连续递增的子序列只跟前一个状态有关</h3><p><a href=https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html>41. 最长上升子序列</a>和<a href=https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html>42. 最长连续递增序列</a>的区别</p><h3 id=两个序列求公共子序列连续子序列只需要考虑相等的情况就可以而不连续但需要保持相对顺序需要考虑其他情况>两个序列求公共子序列，连续子序列只需要考虑相等的情况就可以,而不连续但需要保持相对顺序需要考虑其他情况。</h3><p><a href=https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html>43. 最长重复子数组</a>和<a href=https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html>44. 最长公共子序列</a>的区别</p><h2 id=816---编辑距离问题>8.1.6. 编辑距离问题</h2><h3 id=只涉及删除操作>只涉及删除操作</h3><p><a href=https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html>47. 判断子序列</a>、<a href=https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html>48. 不同的子序列</a>、<a href=https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html>49. 两个字符串的删除操作</a></p><p>这一类问题，基本是要分析两种情况</p><ul><li>情况一：s[i - 1] 与 t[j - 1]相等</li><li>情况二：s[i - 1] 与 t[j - 1] 不相等</li></ul><p>对于情况一，一般就是<code>dp[i][j]和dp[i-1][j-1]</code>相关的操作。 （ 当然根据dp定义还有其他相关的<a href=https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html>48. 不同的子序列</a>）</p><p>对于情况二，一般就是<code>dp[i][j]与dp[i-1][j]、dp[i][j - 1]</code>的操作。</p><p><code>dp[i-1][j]</code>相当于把<code>s[i-1]</code>删掉、<code>dp[i][j - 1]</code>相当于把<code>t[i-1]</code>删掉</p><h3 id=初始化时要根据dp定义来确定>初始化时要根据dp定义来确定</h3><h3 id=50-编辑距离httpsprogrammercarlcom0072编辑距离html><a href=https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html>50. 编辑距离</a></h3><p><strong>删除操作和上文提到的处理方法相同</strong></p><pre tabindex=0><code>if (word1.charAt(i-1) == word2.charAt(j-1)) {
      dp[i][j] = dp[i-1][j-1];
} else {
      dp[i][j] = Math.min(dp[i-1][j] + 1,dp[i][j-1] + 1);
}
</code></pre><p><strong>而新增操作相当于在另一个字符串上的删除操作，所以和删除操作相当于一个情况</strong></p><p>替换操作则是 <code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>具体解释如下：</p><pre tabindex=0><code>if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1];
</code></pre><p><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了，如何编辑呢？</p><ul><li>操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。</li></ul><p>即 <code>dp[i][j] = dp[i - 1][j] + 1;</code></p><ul><li>操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。</li></ul><p>即 <code>dp[i][j] = dp[i][j - 1] + 1;</code></p><p>这里有同学发现了，怎么都是删除元素，添加元素去哪了。<strong>word2添加一个元素，相当于word1删除一个元素</strong>。</p><p>操作三：替换元素，<code>word1</code>替换<code>word1[i - 1]</code>，使其与<code>word2[j - 1]</code>相同，此时不用增删加元素。</p><p>可以回顾一下，<code>if (word1[i - 1] == word2[j - 1])</code>的时候我们的操作 是 <code>dp[i][j] = dp[i - 1][j - 1]</code> 对吧。</p><p>那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。</p><p>所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>综上，当 <code>if (word1[i - 1] != word2[j - 1])</code> 时取最小的，即：<code>dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;</code></p><p>完整代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>minDistance</span>(String word1, String word2) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>word1.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>word2.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> word1.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;=</span> word2.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> j;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> word1.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> word2.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (word1.<span style=color:#50fa7b>charAt</span>(i<span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>==</span> word2.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>                    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span><span style=color:#6272a4>//                    dp[i][j] = Math.min(dp[i-1][j-1] + 1, Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1));</span>
</span></span><span style=display:flex><span>                    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>, Math.<span style=color:#50fa7b>min</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>)) <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>word1.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>][</span>word2.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=82-重点题目及出错的题目等>8.2 重点题目及出错的题目等</h2><h3 id=背包问题相关题目>背包问题相关题目</h3><h3 id=8-整数拆分httpsprogrammercarlcom0343整数拆分html><a href=https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html>8. 整数拆分</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>integerBreak</span>(<span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 3; i <span style=color:#ff79c6>&lt;=</span> n; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> i<span style=color:#ff79c6>/</span>2; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>, Math.<span style=color:#50fa7b>max</span>(j <span style=color:#ff79c6>*</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>j<span style=color:#ff79c6>]</span>, j <span style=color:#ff79c6>*</span> (i<span style=color:#ff79c6>-</span>j)));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=9-不同的二叉搜索树httpsprogrammercarlcom0096不同的二叉搜索树html><a href=https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html>9. 不同的二叉搜索树</a></h3><p><strong><code>dp[i] </code>： 1到i为节点组成的二叉搜索树的个数为<code>dp[i]</code></strong>。</p><p>递推公式：<code>dp[i] += dp[j - 1] * dp[i - j]; </code>，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><p>遍历顺序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> n; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> i; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+=</span> dp<span style=color:#ff79c6>[</span>j <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>*</span> dp<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=13-分割等和子集httpsprogrammercarlcom0416分割等和子集html><a href=https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html>13. 分割等和子集</a></h3><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p><strong>dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]</strong>。</p><p>递推公式：<code>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</code></p><h3 id=14-最后一块石头的重量iihttpsprogrammercarlcom1049最后一块石头的重量iihtml><a href=https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html>14. 最后一块石头的重量II</a></h3><p><a href=https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html>416. 分割等和子集 (opens new window)</a>相当于是求背包是否正好装满，而本题是求背包最多能装多少。</p><p><strong>其中背包容量为sum/2，让背包最多装满多少，之后剩下的部分就是石头剩余的重量。</strong></p><h3 id=16-目标和httpsprogrammercarlcom0494目标和html><a href=https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html>16. 目标和</a></h3><p>本题要如何使表达式结果为target，</p><p>既然为target，那么就一定有 left组合 - right组合 = target。</p><p>left + right = sum，而sum是固定的。right = sum - left</p><p>公式来了， left - (sum - left) = target 推导出 left = (target + sum)/2 。</p><p>target是固定的，sum是固定的，left就可以求出来。</p><p>此时问题就是在集合nums中找出和为left的组合。</p><p>==========================================================</p><p>这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。</p><p><strong>本题则是装满有几种方法</strong>。其实这就是一个组合问题了。</p><h3 id=17-一和零httpsprogrammercarlcom0474一和零html><a href=https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html>17. 一和零</a></h3><p><strong>有两个维度的0-1背包</strong></p><p><strong>本题中strs 数组里的元素就是物品，每个物品都是一个！</strong></p><p><strong>而m 和 n相当于是一个背包，两个维度的背包</strong>。</p><p>动规五部曲：</p><p><strong><code>dp[i][j]</code>：最多有i个0和j个1的strs的最大子集的大小为<code>dp[i][j]</code></strong>。</p><p>递推公式：<code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code></p><p>初始化：均为0；</p><p>遍历顺序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>for</span> (string <span style=color:#8be9fd;font-style:italic>str</span> : strs) { <span style=color:#6272a4>// 遍历物品
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>int</span> oneNum <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>, zeroNum <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>char</span> <span style=color:#8be9fd;font-style:italic>c</span> : str) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (c <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;0&#39;</span>) zeroNum<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> oneNum<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> m; i <span style=color:#ff79c6>&gt;=</span> zeroNum; i<span style=color:#ff79c6>--</span>) { <span style=color:#6272a4>// 遍历背包容量且从后向前遍历！
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> n; j <span style=color:#ff79c6>&gt;=</span> oneNum; j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#ff79c6>=</span> max(dp[i][j], dp[i <span style=color:#ff79c6>-</span> zeroNum][j <span style=color:#ff79c6>-</span> oneNum] <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=26-单词拆分httpsprogrammercarlcom0139单词拆分html><a href=https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html>26. 单词拆分</a></h3><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p><p>递推公式是 <code>if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true</code>。</p><p>dp[0]初始为true完全就是为了推导公式，下标非0的dp[i]初始化为false。</p><p>本题其实我们求的是排列数，所以<strong>外层for遍历背包，内层for循环遍历物品</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>wordBreak</span>(String s, List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> wordDict) {
</span></span><span style=display:flex><span>    HashSet<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> set <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;</span>(wordDict);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> s.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {  <span style=color:#6272a4>//遍历背包</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> j; i<span style=color:#ff79c6>++</span>) {  <span style=color:#6272a4>//遍历物品</span>
</span></span><span style=display:flex><span>            String word <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>substring</span>(i,j);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (set.<span style=color:#50fa7b>contains</span>(word) <span style=color:#ff79c6>&amp;&amp;</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>boolean</span> b : dp) {
</span></span><span style=display:flex><span>        System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>print</span>(b <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=子序列相关题目>子序列相关题目</h3><h3 id=41-最长上升子序列httpsprogrammercarlcom0300最长上升子序列html><a href=https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html>41. 最长上升子序列</a></h3><ul><li>dp[i]的定义</li></ul><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p><ul><li>状态转移方程</li></ul><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：<code>if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);</code></p><ul><li>dp[i]的初始化</li></ul><p>每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p><ul><li>确定遍历顺序</li></ul><p>dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。</p><p>j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。</p><p>遍历i的循环在外层，遍历j则在内层，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> i; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>, dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> ans) ans <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=本题最关键的是要想到dpi由哪些状态可以推出来并取最大值那么很自然就能想到递推公式dpi--maxdpi-dpj--1>本题最关键的是要想到dp[i]由哪些状态可以推出来，并取最大值，那么很自然就能想到递推公式：<code>dp[i] = max(dp[i], dp[j] + 1);</code></h4><h3 id=动态规划最长递增子序列的个数httpsprogrammercarlcom0673最长递增子序列的个数html><a href=https://programmercarl.com/0673.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0.html>动态规划：最长递增子序列的个数</a></h3><ul><li>确定dp数组（dp table）以及下标的含义</li></ul><p>这道题目我们要一起维护两个数组。</p><p>dp[i]：i之前（包括i）最长递增子序列的长度为dp[i]</p><p>count[i]：以nums[i]为结尾的字符串，最长递增子序列的个数为count[i]</p><ul><li>递推公式</li></ul><p>在300.最长上升子序列 中，我们给出的状态转移是：</p><p><code>if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);</code></p><p>即：位置i的最长递增子序列长度 等于j从0到i-1各个位置的最长升序子序列 + 1的最大值。</p><p>本题就没那么简单了，我们要考虑两个维度，一个是dp[i]的更新，一个是count[i]的更新。</p><p>那么如何更新count[i]呢？</p><p>以nums[i]为结尾的字符串，最长递增子序列的个数为count[i]。</p><p>那么在nums[i] > nums[j]前提下，如果在[0, i-1]的范围内，找到了j，使得dp[j] + 1 > dp[i]，说明找到了一个更长的递增子序列。</p><p>那么以j为结尾的子串的最长递增子序列的个数，就是最新的以i为结尾的子串的最长递增子序列的个数，即：<code>count[i] = count[j]。</code></p><p>在nums[i] > nums[j]前提下，如果在[0, i-1]的范围内，找到了j，使得dp[j] + 1 == dp[i]，说明找到了两个相同长度的递增子序列。</p><p>那么以i为结尾的子串的最长递增子序列的个数 就应该加上以j为结尾的子串的最长递增子序列的个数，即：<code>count[i] += count[j];</code></p><ul><li>初始化</li></ul><p>count[i]记录了以nums[i]为结尾的字符串，最长递增子序列的个数。</p><p>那么最少也就是1个，所以count[i]初始为1。</p><p>dp[i]记录了i之前（包括i）最长递增序列的长度。</p><p>最小的长度也是1，所以dp[i]初始为1。</p><ul><li>遍历顺序</li></ul><p>dp[i] 是由0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。</p><p>j其实就是0到i-1，遍历i的循环里外层，遍历j则在内层，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>findNumberOfLIS</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>&lt;=</span> 1) <span style=color:#ff79c6>return</span> nums.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;  <span style=color:#6272a4>//递增子序列的最长长度</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> count <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;  <span style=color:#6272a4>//自增子序列的个数</span>
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>fill</span>(dp,1);
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>fill</span>(count,1);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> maxCount <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> i; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1 <span style=color:#ff79c6>&gt;</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) { <span style=color:#6272a4>//长度增加</span>
</span></span><span style=display:flex><span>                    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>                    count<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> count<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]+</span>1 <span style=color:#ff79c6>==</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {  <span style=color:#6272a4>//长度未增，但个数增加</span>
</span></span><span style=display:flex><span>                    count<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+=</span> count<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> maxCount) maxCount <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;  <span style=color:#6272a4>//记录最长长度</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (maxCount <span style=color:#ff79c6>==</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) ans <span style=color:#ff79c6>+=</span> count<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=43-最长重复子数组httpsprogrammercarlcom0718最长重复子数组html><a href=https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html>43. 最长重复子数组</a></h3><ul><li>确定dp数组（dp table）以及下标的含义</li></ul><p><strong><code>dp[i][j]</code> ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为<code>dp[i][j]</code>。 （<strong>特别注意</strong>： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</strong></p><ul><li>确定递推公式</li></ul><p>根据dp[i][j]的定义，<code>dp[i][j]</code>的状态只能由<code>dp[i - 1][j - 1]</code>推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p><ul><li>dp数组如何初始化</li></ul><p>根据<code>dp[i][j]</code>的定义，<code>dp[i][0]</code>和<code>dp[0][j]</code>其实都是没有意义的！</p><p>但<code>dp[i][0]</code> 和<code>dp[0][j]</code>要初始值，因为 为了方便递归公式<code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>所以<code>dp[i][0] </code>和<code>dp[0][j]</code>初始化为0。</p><p>举个例子A[0]如果和B[0]相同的话，<code>dp[1][1] = dp[0][0] + 1</code>，只有<code>dp[0][0]</code>初始为0，正好符合递推公式逐步累加起来。</p><ul><li>确定遍历顺序</li></ul><p>外层for循环遍历A，内层for循环遍历B。</p><p>那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？</p><p>也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。</p><p>同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把<code>dp[i][j]</code>的最大值记录下来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> nums1.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> nums2.<span style=color:#50fa7b>length</span>; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums1<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> nums2<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> ans) ans <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=44-最长公共子序列httpsprogrammercarlcom1143最长公共子序列html><a href=https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html>44. 最长公共子序列</a></h3><ul><li>确定dp数组（dp table）以及下标的含义</li></ul><p><code>dp[i][j]</code>：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为<code>dp[i][j]</code></p><ul><li>确定递推公式</li></ul><p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以<code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p><p>即：<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (text1.<span style=color:#50fa7b>charAt</span>(i<span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>==</span> text2.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>dp数组如何初始化</li></ul><p>先看看<code>dp[i][0]</code>应该是多少呢？</p><p>test1[0, i-1]和空串的最长公共子序列自然是0，所以<code>dp[i][0] = 0;</code></p><p>同理<code>dp[0][j]</code>也是0。</p><p>其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。</p><ul><li>遍历顺序</li></ul><p>为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-12_11-55-17.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>longestCommonSubsequence</span>(String text1, String text2) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>text1.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>text2.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> text1.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> text2.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (text1.<span style=color:#50fa7b>charAt</span>(i<span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>==</span> text2.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>text1.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>][</span>text2.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=46-最大子序和httpsprogrammercarlcom0053最大子序和动态规划html><a href=https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html>46. 最大子序和</a></h3><p><strong>dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]</strong>。</p><p>dp[i]只有两个方向可以推出来：</p><ul><li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和</li></ul><p>一定是取最大的，所以<code>dp[i] = max(dp[i - 1] + nums[i], nums[i]);</code></p><p>初始化：<code>dp[0] = nums[0]</code></p><p>递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 贪心法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>maxSubArray2</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> max <span style=color:#ff79c6>=</span> Integer.<span style=color:#50fa7b>MIN_VALUE</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> sum <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        sum <span style=color:#ff79c6>+=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (sum <span style=color:#ff79c6>&gt;</span> max) max <span style=color:#ff79c6>=</span> sum;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (sum <span style=color:#ff79c6>&lt;=</span> 0) sum <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> max;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * DP
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>maxSubArray</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>, nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> ans) ans <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=编辑距离相关题目>编辑距离相关题目</h3><h3 id=47-判断子序列httpsprogrammercarlcom0392判断子序列html><a href=https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html>47. 判断子序列</a></h3><p>可以用双指针解决</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 双指针
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param t
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSubsequence</span>(String s, String t) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>equals</span>(<span style=color:#f1fa8c>&#34;&#34;</span>)) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> slow <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> fast <span style=color:#ff79c6>=</span> 0; fast <span style=color:#ff79c6>&lt;</span> t.<span style=color:#50fa7b>length</span>(); fast<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(slow) <span style=color:#ff79c6>==</span> t.<span style=color:#50fa7b>charAt</span>(fast)) {
</span></span><span style=display:flex><span>            slow<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (slow <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>length</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>这道题应该算是编辑距离的入门题目，因为从题意中我们也可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。</strong></p><h4 id=确定dp数组dp-table以及下标的含义>确定dp数组（dp table）以及下标的含义</h4><p><strong><code>dp[i][j]</code> 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为<code>dp[i][j]</code></strong>。</p><h4 id=递推公式-3>递推公式</h4><p>在确定递推公式的时候，首先要考虑如下两种操作，整理如下：</p><ul><li>if (s[i - 1] == t[j - 1])<ul><li>t中找到了一个字符在s中也出现了</li></ul></li><li>if (s[i - 1] != t[j - 1])<ul><li>相当于t要删除元素，继续匹配</li></ul></li></ul><p>if (s[i - 1] == t[j - 1])，那么<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>;，因为找到了一个相同的字符，相同子序列长度自然要在<code>dp[i-1][j-1]</code>的基础上加1</p><p>if (s[i - 1] != t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：<code>dp[i][j] = dp[i][j - 1];</code></p><p>其实这里 大家可以发现和 <a href=https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html>1143.最长公共子序列 (opens new window)</a>的递推公式基本那就是一样的，区别就是 本题 如果删元素一定是字符串t，而 1143.最长公共子序列 是两个字符串都可以删元素。</p><h4 id=初始化-3>初始化</h4><p>从递推公式可以看出dp[i][j]都是依赖于<code>dp[i - 1][j - 1] </code>和<code> dp[i][j - 1]</code>，所以<code>dp[0][0]和dp[i][0]</code>是一定要初始化的。</p><p><code>dp[0][0]和dp[i][0]</code>都初始化为0；</p><h4 id=确定遍历顺序>确定遍历顺序</h4><p>同理从递推公式可以看出dp[i][j]都是依赖于<code>dp[i - 1][j - 1] 和 dp[i][j - 1]</code>，那么遍历顺序也应该是从上到下，从左到右</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSubsequence2</span>(String s, String t) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>t.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> t.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i<span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>==</span> t.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>][</span>t.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>length</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=48-不同的子序列httpsprogrammercarlcom0115不同的子序列html><a href=https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html>48. 不同的子序列</a></h3><ul><li>确定dp数组（dp table）以及下标的含义</li></ul><p><strong><code>dp[i][j]</code>：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为<code>dp[i][j]</code>。</strong></p><ul><li>递推公式</li></ul><p>这一类问题，基本是要分析两种情况</p><ul><li>s[i - 1] 与 t[j - 1]相等</li><li>s[i - 1] 与 t[j - 1] 不相等</li></ul><p><strong>当s[i - 1] 与 t[j - 1]相等时，<code>dp[i][j]</code>可以有两部分组成。</strong></p><p><strong>一部分是用s[i - 1]来匹配，那么个数为<code>dp[i - 1][j - 1]</code>。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 <code>dp[i-1][j-1]</code>。</strong></p><p><strong>一部分是不用s[i - 1]来匹配，个数为<code>dp[i - 1][j]</code>。</strong></p><p>例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。</p><p>当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p><p><strong>所以当s[i - 1] 与 t[j - 1]相等时，<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</code></strong></p><p><strong>当s[i - 1] 与 t[j - 1]不相等时，<code>dp[i][j]</code>只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：<code>dp[i - 1][j]</code></strong></p><p><strong>所以当s[i - 1] 与 t[j - 1]不相等时：<code>dp[i][j] = dp[i - 1][j];</code></strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i<span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>==</span> t.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>初始化</li></ul><p>从递推公式<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; </code>中可以看出<code>dp[i][j] </code>是从上方和左上方推导而来，如图：，那么 <code>dp[i][0] 和dp[0][j]</code>是一定要初始化的。</p><p>每次当初始化的时候，都要回顾一下<code>dp[i][j]</code>的定义，不要凭感觉初始化。</p><p><code>dp[i][0] </code>表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。</p><p>那么<code>dp[i][0]</code>一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。</p><p><code>dp[0][j]</code>：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。</p><p>那么<code>dp[0][j]</code>一定都是0，s如论如何也变成不了t。</p><p>最后就要看一个特殊位置了，即：<code>dp[0][0] </code>应该是多少。</p><p><code>dp[0][0]</code>应该是1，空字符串s，可以删除0个元素，变成空字符串t。</p><ul><li>遍历顺序</li></ul><p>所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>numDistinct</span>(String s, String t) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>t.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> t.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i<span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>==</span> t.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>][</span>t.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=49-两个字符串的删除操作httpsprogrammercarlcom0583两个字符串的删除操作html><a href=https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html>49. 两个字符串的删除操作</a></h3><p><code>dp[i][j]</code>：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><ul><li>递归函数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> word1.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> word2.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (word1.<span style=color:#50fa7b>charAt</span>(i<span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>==</span> word2.<span style=color:#50fa7b>charAt</span>(j<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>初始化</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> word1.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;=</span> word2.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> j;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=52-回文子串httpsprogrammercarlcom0647回文子串html><a href=https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html>52. 回文子串</a></h3><h4 id=双指针法-1>双指针法</h4><p>以中间向两边扩散，其中可以作为中间点的可以是一个元素或者两个元素</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 双指针
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>countSubstrings</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> result <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        result <span style=color:#ff79c6>+=</span> extend(s,i,i,s.<span style=color:#50fa7b>length</span>());
</span></span><span style=display:flex><span>        result <span style=color:#ff79c6>+=</span> extend(s,i,i<span style=color:#ff79c6>+</span>1,s.<span style=color:#50fa7b>length</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>extend</span>(String s, <span style=color:#8be9fd>int</span> i, <span style=color:#8be9fd>int</span> j, <span style=color:#8be9fd>int</span> length) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>&gt;</span> j) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (;i <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> j <span style=color:#ff79c6>&lt;</span> length; i<span style=color:#ff79c6>--</span>,j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j)){
</span></span><span style=display:flex><span>            res<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=dp方法>DP方法</h4><ul><li>确定dp数组（dp table）以及下标的含义</li></ul><p><strong>布尔类型的<code>dp[i][j]</code>：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是<code>dp[i][j]</code>为true，否则为false。</strong></p><ul><li>递推公式</li></ul><p>当s[i]与s[j]不相等，那没啥好说的了，<code>dp[i][j]</code>一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看<code>dp[i + 1][j - 1]</code>是否为true。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>if</span> (s[i] <span style=color:#ff79c6>==</span> s[j]) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>&lt;=</span> <span style=color:#bd93f9>1</span>) { <span style=color:#6272a4>// 情况一 和 情况二
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        result<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        dp[i][j] <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>true</span>;
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> <span style=color:#50fa7b>if</span> (dp[i <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>][j <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>]) { <span style=color:#6272a4>// 情况三
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        result<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        dp[i][j] <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p><code>dp[i][j]</code>初始化为false。</p></li><li><p>遍历顺序</p></li></ul><p><strong>一定要从下到上，从左到右遍历，这样保证<code>dp[i + 1][j - 1]</code>都是经过计算的</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * DP方法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>countSubstrings2</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>][</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> i; j <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j)) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>&lt;=</span> 1){
</span></span><span style=display:flex><span>                    res<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                    res<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=动态规划最长回文子串httpsprogrammercarlcom0005最长回文子串html><a href=https://programmercarl.com/0005.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html>动态规划：最长回文子串</a></h3><p>与<a href=https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html>52. 回文子串</a>是同一种题</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 双指针法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> String <span style=color:#50fa7b>longestPalindrome</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>length</span>() <span style=color:#ff79c6>&lt;=</span> 1) <span style=color:#ff79c6>return</span> s;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> start <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> maxlen <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> len1 <span style=color:#ff79c6>=</span> extend(s,i,i,s.<span style=color:#50fa7b>length</span>());
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> len2 <span style=color:#ff79c6>=</span> extend(s,i,i<span style=color:#ff79c6>+</span>1,s.<span style=color:#50fa7b>length</span>());
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(len1,len2);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (maxlen <span style=color:#ff79c6>&lt;</span> len) {
</span></span><span style=display:flex><span>            maxlen <span style=color:#ff79c6>=</span> len;
</span></span><span style=display:flex><span>            start <span style=color:#ff79c6>=</span> i <span style=color:#ff79c6>-</span> (maxlen <span style=color:#ff79c6>-</span> 1) <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> s.<span style=color:#50fa7b>substring</span>(start,start<span style=color:#ff79c6>+</span>maxlen);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>extend</span>(String s, <span style=color:#8be9fd>int</span> left, <span style=color:#8be9fd>int</span> right, <span style=color:#8be9fd>int</span> length) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>&lt;</span> length <span style=color:#ff79c6>&amp;&amp;</span> s.<span style=color:#50fa7b>charAt</span>(left) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(right)) {
</span></span><span style=display:flex><span>        len <span style=color:#ff79c6>=</span> right <span style=color:#ff79c6>-</span> left <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>        left<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>        right<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> len;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * DP
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> String <span style=color:#50fa7b>longestPalindrome2</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>length</span>() <span style=color:#ff79c6>&lt;=</span> 1) <span style=color:#ff79c6>return</span> s;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>][</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> maxlen <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> start <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> i; j <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j)) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>&lt;=</span> 1) {
</span></span><span style=display:flex><span>                    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> maxlen <span style=color:#ff79c6>&lt;</span> j <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>+</span> 1) {
</span></span><span style=display:flex><span>                maxlen <span style=color:#ff79c6>=</span> j <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>                start <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> s.<span style=color:#50fa7b>substring</span>(start,start<span style=color:#ff79c6>+</span>maxlen);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=动态规划分割回文串iihttpsprogrammercarlcom0132分割回文串iihtml><a href=https://programmercarl.com/0132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2II.html>动态规划：分割回文串II</a></h3><p>先用一个二维数组来保存整个字符串的回文情况。就是<a href=https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html>52. 回文子串</a>和<a href=https://programmercarl.com/0005.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html>动态规划：最长回文子串</a>中的方法。</p><ul><li>确定dp数组（dp table）以及下标的含义</li></ul><p>dp[i]：范围是[0, i]的回文子串，最少分割次数是dp[i]。</p><ul><li>递归公式</li></ul><p>如果要对长度为[0, i]的子串进行分割，分割点为j。</p><p>那么如果分割后，区间[j + 1, i]是回文子串，那么dp[i] 就等于 dp[j] + 1。</p><p>[0, j]区间的最小切割数量，我们已经知道了就是dp[j]。</p><p>此时就找到了递推关系，当切割点j在[0, i] 之间时候，dp[i] = dp[j] + 1;</p><p>本题是要找到最少分割次数，所以遍历j的时候要取最小的dp[i]。</p><p><strong>所以最后递推公式为：dp[i] = min(dp[i], dp[j] + 1);</strong></p><ul><li>初始化</li></ul><p>dp[i]的最大值其实就是i，也就是把每个字符分割出来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> s.size(); i<span style=color:#ff79c6>++</span>) dp[i] <span style=color:#ff79c6>=</span> i;
</span></span></code></pre></div><ul><li>遍历顺序</li></ul><p>j是在[0，i]之间，所以遍历i的for循环一定在外层，这里遍历j的for循环在内层才能通过 计算过的dp[j]数值推导出dp[i]。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>minCut</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> isHuiWen <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>][</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> i; j <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j)) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>&lt;=</span> 1) {
</span></span><span style=display:flex><span>                    isHuiWen<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (isHuiWen<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                    isHuiWen<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (isHuiWen<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> i; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (isHuiWen<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=53-最长回文子序列httpsprogrammercarlcom0516最长回文子序列html><a href=https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html>53. 最长回文子序列</a></h3><p><strong><code>dp[i][j]</code>：字符串s在[i, j]范围内最长的回文子序列的长度为<code>dp[i][j]</code></strong>。</p><ul><li>递推公式</li></ul><p>如果s[i]与s[j]相同，那么<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code></p><p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p><p>加入s[j]的回文子序列长度为<code>dp[i + 1][j]。</code></p><p>加入s[i]的回文子序列长度为<code>dp[i][j - 1]。</code></p><p>那么<code>dp[i][j]</code>一定是取最大的，即：<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j)) {
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 2;
</span></span><span style=display:flex><span>} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>初始化</li></ul><p>首先要考虑当i 和j 相同的情况，从递推公式：<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code> 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。</p><p>其他情况<code>dp[i][j]</code>初始为0就行，这样递推公式：<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</code> 中dp[i][j]才不会被初始值覆盖。</p><pre tabindex=0><code>int[][] dp = new int[s.length()][s.length()];

for (int i = 0; i &lt; s.length(); i++) {
    dp[i][i] = 1;
}
</code></pre><ul><li>遍历顺序</li></ul><p><strong>所以遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的</strong>。</p><p>j的话，可以正常从左向右遍历。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>longestPalindromeSubseq</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>][</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> i <span style=color:#ff79c6>+</span> 1; j <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> s.<span style=color:#50fa7b>charAt</span>(j)) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 2;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=9-单调栈>9. 单调栈</h1><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</p><p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p><p><strong>更直白来说，就是用一个栈来记录我们遍历过的元素</strong>，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。</p><p>这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。</p><p>即：<strong>如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。</strong></p><h2 id=91-做题总结与技巧>9.1 做题总结与技巧</h2><h3 id=通常是一维数组要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置此时我们就要想到可以用单调栈了时间复杂度为on><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</h3><h3 id=用一个栈来记录我们遍历过的元素单调栈里只需要存放元素的下标i>用一个栈来记录我们遍历过的元素，单调栈里只需要存放元素的下标i。</h3><h3 id=如果求一个元素右边第一个更大元素单调栈就是递增的如果求一个元素右边第一个更小元素单调栈就是递减的>如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。</h3><h3 id=注意递增是指当进栈元素大于栈头元素时需要pop栈头之后元素进栈相反递减是指进栈元素小于栈头元素时需要pop栈头之后元素进栈>注意：递增是指当进栈元素大于栈头元素时需要pop栈头，之后元素进栈；相反，递减是指进栈元素小于栈头元素时需要pop栈头，之后元素进栈</h3><h2 id=92-重点题目及出错的题目等>9.2 重点题目及出错的题目等</h2><h3 id=2-下一个更大元素ihttpsprogrammercarlcom0496下一个更大元素ihtml><a href=https://programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html>2. 下一个更大元素I</a></h3><p>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</p><p>此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。</p><p>判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>nextGreaterElement</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums1, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums2) {
</span></span><span style=display:flex><span>    HashMap<span style=color:#ff79c6>&lt;</span>Integer,Integer<span style=color:#ff79c6>&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums1.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>fill</span>(ans,<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums1.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        map.<span style=color:#50fa7b>put</span>(nums1<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>, i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stack.<span style=color:#50fa7b>push</span>(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> nums2.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums2<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;=</span> nums2<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> nums2<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> nums2<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (map.<span style=color:#50fa7b>containsKey</span>(nums2<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>)){
</span></span><span style=display:flex><span>                    Integer index <span style=color:#ff79c6>=</span> map.<span style=color:#50fa7b>get</span>(nums2<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>                    ans<span style=color:#ff79c6>[</span>index<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums2<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-下一个更大元素iihttpsprogrammercarlcom0503下一个更大元素iihtml><a href=https://programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html>3. 下一个更大元素II</a></h3><h4 id=循环数组如何模拟遍历两遍>循环数组如何模拟遍历两遍</h4><p>本题变为了<strong>循环数组</strong></p><p>有一个模拟循环两边数组的方法，就是取余</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>nextGreaterElements</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>fill</span>(ans,<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> n <span style=color:#ff79c6>*</span> 2; i<span style=color:#ff79c6>++</span>) {  <span style=color:#6272a4>//模拟循环两边数组</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>%</span> n<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> nums<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>%</span> n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        stack.<span style=color:#50fa7b>push</span>(i <span style=color:#ff79c6>%</span> n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-接雨水httpsprogrammercarlcom0042接雨水html><a href=https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html>4. 接雨水</a></h3><p><strong>实际上是要找当前柱子的左右第一个高的柱子。</strong></p><h4 id=双指针法-2>双指针法</h4><p>循环过程中每次都找左右两个柱子进行计算。</p><h4 id=双指针优化>双指针优化</h4><p>先用两个数组（左边第一个高柱子、右边第一个高柱子）记录，然后再遍历进行计算。</p><h4 id=单调栈>单调栈</h4><p>在遍历的的过程中找到左右第一个高的柱子然后进行计算。</p><p><strong>按行计算大小。</strong></p><p>有以下三种情况：</p><ul><li>情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 height[i] &lt; height[st.top()]</li></ul><p>直接进栈</p><ul><li>情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 height[i] == height[st.top()]</li></ul><p>只保留最新的，原先的出栈，新的进栈</p><ul><li>情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 height[i] > height[st.top()]</li></ul><p>此时弹出中间凹下去的那个柱子，作为mid。然后此时的栈头是左面第一个高的柱子，height[i]是右面第一个高的柱子。</p><p>积水决定于两者小的那个高度。<code>int h = Math.min(height[i],height[stack.peek()]) - height[mid];</code></p><p>宽度只算中间的柱子。<code>int w = i - stack.peek() - 1;</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>trap</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> height) {
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> deque <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> sum <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    deque.<span style=color:#50fa7b>push</span>(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> height.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (height<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> height<span style=color:#ff79c6>[</span>deque.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (height<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> height<span style=color:#ff79c6>[</span>deque.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> height<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> height<span style=color:#ff79c6>[</span>deque.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> mid <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>peek</span>();
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>int</span> curHeight <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(height<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>,height<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>-</span> height<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>int</span> curLen <span style=color:#ff79c6>=</span> i <span style=color:#ff79c6>-</span> left <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>                    sum <span style=color:#ff79c6>+=</span> curHeight <span style=color:#ff79c6>*</span> curLen;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            deque.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-柱状图中最大的矩形httpsprogrammercarlcom0084柱状图中最大的矩形html><a href=https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html>5. 柱状图中最大的矩形</a></h3><p><strong>本题与<a href=https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html>4. 接雨水</a>相反，是找当前柱子的左右第一个低的柱子。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>largestRectangleArea</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> heights) {
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> newHeight <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>heights.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>+</span> 2<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    System.<span style=color:#50fa7b>arraycopy</span>(heights,0,newHeight,1,heights.<span style=color:#50fa7b>length</span>);
</span></span><span style=display:flex><span>    newHeight<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    newHeight<span style=color:#ff79c6>[</span>heights.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stack.<span style=color:#50fa7b>push</span>(0);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> newHeight.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (newHeight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> newHeight<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (newHeight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> newHeight<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> newHeight<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> newHeight<span style=color:#ff79c6>[</span>stack.<span style=color:#50fa7b>peek</span>()<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> mid <span style=color:#ff79c6>=</span> stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>int</span> h <span style=color:#ff79c6>=</span> newHeight<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>int</span> w <span style=color:#ff79c6>=</span> i <span style=color:#ff79c6>-</span> stack.<span style=color:#50fa7b>peek</span>() <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>                    res <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(res,h<span style=color:#ff79c6>*</span>w);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=10--图论>10. 图论</h1><h2 id=101-做题总结与技巧>10.1 做题总结与技巧</h2><h3 id=邻接表法建图>邻接表法建图</h3><h4 id=无权图>无权图</h4><pre tabindex=0><code>List&lt;Integer&gt;[] graph = new LinkedList[V];
for (int i = 0; i &lt; V; i++) {
    graph[i] = new LinkedList&lt;&gt;();
}
</code></pre><h4 id=有权图>有权图</h4><pre tabindex=0><code>List&lt;int[]&gt;[] graph = new LinkedList[V];
for (int i = 0; i &lt; numCourses; i++) {
    graph[i] = new LinkedList&lt;&gt;();
}
</code></pre><h2 id=1011---深搜三部曲与回溯中的递归三部曲类似>10.1.1 深搜三部曲（与回溯中的递归三部曲类似）</h2><h4 id=确认递归函数参数>确认递归函数，参数</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8be9fd>void</span> dfs(参数)
</span></span></code></pre></div><p>一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(); <span style=color:#6272a4>// 保存符合条件的所有路径</span>
</span></span><span style=display:flex><span>LinkedList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>(); <span style=color:#6272a4>// 起点到终点的路径</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dfs</span> (图，目前搜索的节点)  
</span></span></code></pre></div><h4 id=确认终止条件>确认终止条件</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>if</span> (终止条件) {
</span></span><span style=display:flex><span>    存放结果;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>终止添加不仅是结束本层递归，同时也是我们收获结果的时候。</p><p>另外，其实很多dfs写法，没有写终止条件，其实终止条件写在了， 下面dfs递归的逻辑里了，也就是不符合条件，直接不会向下递归。这里如果大家不理解的话，没关系，后面会有具体题目来讲解。</p><h4 id=处理目前搜索节点出发的路径>处理目前搜索节点出发的路径</h4><p>一般这里就是一个for循环的操作，去遍历 目前搜索节点 所能到的所有节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>for</span> (选择：本节点所连接的其他节点) {
</span></span><span style=display:flex><span>    处理节点;
</span></span><span style=display:flex><span>    dfs(图，选择的节点); <span style=color:#6272a4>// 递归
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    回溯，撤销处理结果
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=模板题2-所有可能的路径httpsprogrammercarlcom0797所有可能的路径html>模板题<a href=https://programmercarl.com/0797.%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84.html>2. 所有可能的路径</a></h4><ul><li>确认递归函数，参数</li></ul><p>首先我们dfs函数一定要存一个图，用来遍历的，还要存一个目前我们遍历的节点，定义为x</p><ul><li>终止条件</li></ul><p>当目前遍历的节点 为 最后一个节点的时候，就找到了一条，从 出发点到终止点的路径。</p><p>当前遍历的节点，我们定义为x，最后一点节点，就是 graph.size() - 1（因为题目描述是找出所有从节点 0 到节点 n-1 的路径并输出）。</p><ul><li>处理目前搜索节点出发的路径</li></ul><p>接下来是走 当前遍历节点x的下一个节点。首先是要找到 x节点链接了哪些节点呢，接下来就是将 选中的x所连接的节点，加入到 单一路径来。</p><ul><li>完整代码：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>LinkedList<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>allPathsSourceTarget</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> graph) {
</span></span><span style=display:flex><span>    path.<span style=color:#50fa7b>add</span>(0);
</span></span><span style=display:flex><span>    dfs(graph,0);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dfs</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> graph, <span style=color:#8be9fd>int</span> x) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (x <span style=color:#ff79c6>==</span> graph.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1) {
</span></span><span style=display:flex><span>        res.<span style=color:#50fa7b>add</span>(<span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> graph<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>add</span>(graph<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        dfs(graph,graph<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        path.<span style=color:#50fa7b>removeLast</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=这种有向图路径问题最合适使用深搜>这种有向图路径问题，最合适使用深搜.</h3><h3 id=而深搜和广搜都适合解决颜色类的问题例如岛屿系列其实都是-遍历标记所以使用哪种遍历都是可以的>而深搜和广搜都适合解决颜色类的问题，例如岛屿系列，其实都是 遍历+标记，所以使用哪种遍历都是可以的。</h3><h4 id=模板题4-岛屿数量深搜版httpsprogrammercarlcom0200岛屿数量深搜版html>模板题<a href=https://programmercarl.com/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.%E6%B7%B1%E6%90%9C%E7%89%88.html>4. 岛屿数量.深搜版</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dir <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        {0,1},{1,0},{<span style=color:#ff79c6>-</span>1,0},{0,<span style=color:#ff79c6>-</span>1}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>numIslands</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> grid) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m  <span style=color:#ff79c6>=</span> grid.<span style=color:#50fa7b>length</span>;;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>m<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;1&#39;</span>) {
</span></span><span style=display:flex><span>                visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                res<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                dfs(grid,visited,i,j);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dfs</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> grid, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited, <span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 4; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nextx <span style=color:#ff79c6>=</span> x <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nexty <span style=color:#ff79c6>=</span> y <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nextx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nextx <span style=color:#ff79c6>&gt;=</span> grid.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&gt;=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;1&#39;</span>) {
</span></span><span style=display:flex><span>            visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>            dfs(grid, visited, nextx, nexty);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=1012---广搜的搜索方式就适合于解决两个点之间的最短路径问题>10.1.2 广搜的搜索方式就适合于解决两个点之间的最短路径问题。</h2><h4 id=广搜模板题5-岛屿数量广搜版httpsprogrammercarlcom0200岛屿数量广搜版html>广搜模板题<a href=https://programmercarl.com/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.%E5%B9%BF%E6%90%9C%E7%89%88.html>5. 岛屿数量.广搜版</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dir <span style=color:#ff79c6>=</span> {{0, 1}, {0, <span style=color:#ff79c6>-</span>1}, {1, 0}, {<span style=color:#ff79c6>-</span>1, 0}}; <span style=color:#6272a4>// 表示四个方向</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// grid 是地图，也就是一个二维数组</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// visited标记访问过的节点，不要重复访问</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// x,y 表示开始搜索节点的下标</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>bfs</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> grid, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited, <span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y) {
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;</span> deque <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    deque.<span style=color:#50fa7b>offer</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{x,y});  <span style=color:#6272a4>// 起始节点加入队列</span>
</span></span><span style=display:flex><span>    visited<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>y<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;   <span style=color:#6272a4>// 只要加入队列，立刻标记为访问过的节点</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>()) { <span style=color:#6272a4>// 开始遍历队列里的元素</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> cur <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>poll</span>();  <span style=color:#6272a4>// 从队列取元素</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> curx <span style=color:#ff79c6>=</span> cur<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> cury <span style=color:#ff79c6>=</span> cur<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;  <span style=color:#6272a4>// 当前节点坐标</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 4; i<span style=color:#ff79c6>++</span>) { <span style=color:#6272a4>// 开始想当前节点的四个方向左右上下去遍历</span>
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> nextx <span style=color:#ff79c6>=</span> curx <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> nexty <span style=color:#ff79c6>=</span> cury <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>; <span style=color:#6272a4>// 获取周边四个方向的坐标</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nextx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nextx <span style=color:#ff79c6>&gt;=</span> grid.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&gt;=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span>) {<span style=color:#6272a4>// 如果节点没被访问过</span>
</span></span><span style=display:flex><span>                deque.<span style=color:#50fa7b>push</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{nextx,nexty});   <span style=color:#6272a4>// 队列添加该节点为下一轮要遍历的节点</span>
</span></span><span style=display:flex><span>                visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;  <span style=color:#6272a4>// 只要加入队列立刻标记，避免重复访问</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=1013---并查集>10.1.3 并查集</h2><h3 id=并查集常用来解决连通性问题就是当我们需要判断两个元素是否在同一个集合里的时候我们就要想到用并查集以及无向图的有环无环问题>并查集常用来解决连通性问题。就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。以及无向图的有环无环问题。</h3><p>并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合</li></ul><p>我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是将三个元素连通在一起，如何连通呢。</p><p>只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。</p><h3 id=代码模板>代码模板：</h3><h4 id=labuladong版本>labuladong版本：</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>UF</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> count;  <span style=color:#6272a4>// 连通分量个数</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> father; <span style=color:#6272a4>// 父节点数组</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 构造函数，初始化父节点数组</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>UF</span>(<span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>count</span> <span style=color:#ff79c6>=</span> n;
</span></span><span style=display:flex><span>        father <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> n; <span style=color:#ff79c6>++</span>i) {
</span></span><span style=display:flex><span>            father<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 并查集里寻根的过程</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>find</span>(<span style=color:#8be9fd>int</span> u) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>return</span> u;
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 路径压缩</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>return</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> find(father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断 u 和 v是否找到同一个根</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSame</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>        u <span style=color:#ff79c6>=</span> find(u);
</span></span><span style=display:flex><span>        v <span style=color:#ff79c6>=</span> find(v);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> u <span style=color:#ff79c6>==</span> v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将v-&gt;u 这条边加入并查集</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>join</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>        u <span style=color:#ff79c6>=</span> find(u); <span style=color:#6272a4>// 寻找u的根</span>
</span></span><span style=display:flex><span>        v <span style=color:#ff79c6>=</span> find(v); <span style=color:#6272a4>// 寻找v的根</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> v) <span style=color:#ff79c6>return</span>; <span style=color:#6272a4>// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span>
</span></span><span style=display:flex><span>        father<span style=color:#ff79c6>[</span>v<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> u;
</span></span><span style=display:flex><span>        count<span style=color:#ff79c6>--</span>;  <span style=color:#6272a4>// 两个连通分量合并成一个连通分量</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 返回图中的连通分量个数</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>count</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=代码随想录版本>代码随想录版本：</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>BingChaJi</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> 1005; <span style=color:#6272a4>// n根据题目中节点数量而定，一般比节点数量大一点就好</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> father <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>]</span>;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 并查集初始化</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>init</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> n; <span style=color:#ff79c6>++</span>i) {
</span></span><span style=display:flex><span>            father<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 并查集里寻根的过程</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>find</span>(<span style=color:#8be9fd>int</span> u) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>return</span> u;
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 路径压缩</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>return</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> find(father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断 u 和 v是否找到同一个根</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSame</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>        u <span style=color:#ff79c6>=</span> find(u);
</span></span><span style=display:flex><span>        v <span style=color:#ff79c6>=</span> find(v);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> u <span style=color:#ff79c6>==</span> v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将v-&gt;u 这条边加入并查集</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>join</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>        u <span style=color:#ff79c6>=</span> find(u); <span style=color:#6272a4>// 寻找u的根</span>
</span></span><span style=display:flex><span>        v <span style=color:#ff79c6>=</span> find(v); <span style=color:#6272a4>// 寻找v的根</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> v) <span style=color:#ff79c6>return</span> ; <span style=color:#6272a4>// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span>
</span></span><span style=display:flex><span>        father<span style=color:#ff79c6>[</span>v<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> u;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=通过模板我们可以知道并查集主要有三个功能>通过模板，我们可以知道，并查集主要有三个功能。</h3><ol><li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</li></ol><h3 id=模板题15-寻找图中是否存在路径httpsprogrammercarlcom1971寻找图中是否存在路径html>模板题<a href=https://programmercarl.com/1971.%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84.html>15. 寻找图中是否存在路径</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> father;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>validPath</span>(<span style=color:#8be9fd>int</span> n, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> edges, <span style=color:#8be9fd>int</span> source, <span style=color:#8be9fd>int</span> destination) {
</span></span><span style=display:flex><span>    father <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    init();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> edges.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        join(edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>,edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> isSame(source,destination);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> father.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        father<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>find</span>(<span style=color:#8be9fd>int</span> u) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>return</span> u;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>return</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> find(father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSame</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>    u <span style=color:#ff79c6>=</span> find(u);
</span></span><span style=display:flex><span>    v <span style=color:#ff79c6>=</span> find(v);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> u <span style=color:#ff79c6>==</span> v;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>join</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>    u <span style=color:#ff79c6>=</span> find(u);
</span></span><span style=display:flex><span>    v <span style=color:#ff79c6>=</span> find(v);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> v) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    father<span style=color:#ff79c6>[</span>v<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> u;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=1014--dfsbfs有向图有环问题---拓扑排序>10.1.4 DFS/BFS有向图有环问题 拓扑排序</h2><h3 id=经典题207-课程表httpsleetcodecnproblemscourse-schedule>经典题：<a href=https://leetcode.cn/problems/course-schedule/>207. 课程表</a></h3><h4 id=dfs判断是否有环>DFS判断是否有环</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> visited;  <span style=color:#6272a4>//是否访问过该节点</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> onPath;  <span style=color:#6272a4>//// 记录一次递归堆栈中的节点  记录当前 traverse 经过的路径</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>boolean</span> hasCycle <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>; <span style=color:#6272a4>// 记录图中是否有环</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>canFinish</span>(<span style=color:#8be9fd>int</span> numCourses, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> prerequisites) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> graph <span style=color:#ff79c6>=</span> buildGraph(numCourses, prerequisites);
</span></span><span style=display:flex><span>    visited <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    onPath <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> numCourses; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        traversal(graph,i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>!</span>hasCycle;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> <span style=color:#50fa7b>buildGraph</span>(<span style=color:#8be9fd>int</span> numCourses, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> prerequisites) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 图中共有 numCourses 个节点</span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> graph <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> numCourses; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        graph<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> edge : prerequisites) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> from <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>, to <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 添加一条从 from 指向 to 的有向边</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span>
</span></span><span style=display:flex><span>        graph<span style=color:#ff79c6>[</span>from<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>add</span>(to);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> graph;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>traversal</span>(List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> graph, <span style=color:#8be9fd>int</span> s) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (onPath<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//发现有环</span>
</span></span><span style=display:flex><span>        hasCycle <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 从节点 s 开始 DFS 遍历，将遍历过的节点标记为 true</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (visited<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>||</span> hasCycle) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将节点 s 标记为已遍历</span>
</span></span><span style=display:flex><span>    visited<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 开始遍历节点 s</span>
</span></span><span style=display:flex><span>    onPath<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (Integer t : graph<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>        traversal(graph, t);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 节点 s 遍历完成</span>
</span></span><span style=display:flex><span>    onPath<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=bfs判断是否有环>BFS判断是否有环</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * bfs
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param numCourses
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param prerequisites
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>canFinishBFS</span>(<span style=color:#8be9fd>int</span> numCourses, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> prerequisites) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 建图，有向边代表「被依赖」关系</span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> graph <span style=color:#ff79c6>=</span> buildGraph(numCourses, prerequisites);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 构建入度数组</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> indegree <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> edge : prerequisites) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> from <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>, to <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 节点 to 的入度加一</span>
</span></span><span style=display:flex><span>        indegree<span style=color:#ff79c6>[</span>to<span style=color:#ff79c6>]++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 根据入度初始化队列中的节点</span>
</span></span><span style=display:flex><span>    Queue<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> q <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> numCourses; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (indegree<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 节点 i 没有入度，即没有依赖的节点</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 可以作为拓扑排序的起点，加入队列</span>
</span></span><span style=display:flex><span>            q.<span style=color:#50fa7b>offer</span>(i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 记录遍历的节点个数</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 开始执行 BFS 循环</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>q.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 弹出节点 cur，并将它指向的节点的入度减一</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> cur <span style=color:#ff79c6>=</span> q.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>        count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> next : graph<span style=color:#ff79c6>[</span>cur<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            indegree<span style=color:#ff79c6>[</span>next<span style=color:#ff79c6>]--</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (indegree<span style=color:#ff79c6>[</span>next<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 如果入度变为 0，说明 next 依赖的节点都已被遍历</span>
</span></span><span style=display:flex><span>                q.<span style=color:#50fa7b>offer</span>(next);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果所有节点都被遍历过，说明不成环</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> count <span style=color:#ff79c6>==</span> numCourses;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=经典题210-课程表-iihttpsleetcodecnproblemscourse-schedule-ii>经典题：<a href=https://leetcode.cn/problems/course-schedule-ii/>210. 课程表 II</a></h3><h4 id=dfs实现拓扑排序>DFS实现拓扑排序</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> visited;
</span></span><span style=display:flex><span><span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> onPath;
</span></span><span style=display:flex><span><span style=color:#8be9fd>boolean</span> hasCycle <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> path <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>findOrder</span>(<span style=color:#8be9fd>int</span> numCourses, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> prerequisites) {
</span></span><span style=display:flex><span>    visited <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    onPath <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> graph <span style=color:#ff79c6>=</span> buildGraph(numCourses, prerequisites);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> numCourses; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dfs(graph,i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (hasCycle) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{};
</span></span><span style=display:flex><span>    Collections.<span style=color:#50fa7b>reverse</span>(path); <span style=color:#6272a4>// 将后序遍历的结果进行反转，就是拓扑排序的结果。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> res <span style=color:#ff79c6>=</span> path.<span style=color:#50fa7b>stream</span>().<span style=color:#50fa7b>mapToInt</span>(Integer::intValue).<span style=color:#50fa7b>toArray</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> <span style=color:#50fa7b>buildGraph</span>(<span style=color:#8be9fd>int</span> numCourses, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> prerequisites) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> graph <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> graph.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        graph<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> prerequisite : prerequisites) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> from <span style=color:#ff79c6>=</span> prerequisite<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> to <span style=color:#ff79c6>=</span> prerequisite<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        graph<span style=color:#ff79c6>[</span>from<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>add</span>(to);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> graph;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dfs</span>(List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> graph, <span style=color:#8be9fd>int</span> s) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (onPath<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>        hasCycle <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (visited<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>||</span> hasCycle) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    visited<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    onPath<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (Integer x : graph<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>        dfs(graph,x);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    path.<span style=color:#50fa7b>add</span>(s);   <span style=color:#6272a4>//访问完添加</span>
</span></span><span style=display:flex><span>    onPath<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=bfs实现拓扑排序>BFS实现拓扑排序</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * BFS
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param numCourses
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param prerequisites
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>findOrderBFS</span>(<span style=color:#8be9fd>int</span> numCourses, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> prerequisites) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 建图，和环检测算法相同</span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;[]</span> graph <span style=color:#ff79c6>=</span> buildGraph(numCourses, prerequisites);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 计算入度，和环检测算法相同</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> indegree <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> edge : prerequisites) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> from <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>, to <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        indegree<span style=color:#ff79c6>[</span>to<span style=color:#ff79c6>]++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 根据入度初始化队列中的节点，和环检测算法相同</span>
</span></span><span style=display:flex><span>    Queue<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> q <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> numCourses; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (indegree<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>            q.<span style=color:#50fa7b>offer</span>(i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 记录拓扑排序结果</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>numCourses<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 记录遍历节点的顺序（索引）</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 开始执行 BFS 算法</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>q.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> cur <span style=color:#ff79c6>=</span> q.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 弹出节点的顺序即为拓扑排序结果</span>
</span></span><span style=display:flex><span>        res<span style=color:#ff79c6>[</span>count<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> cur;
</span></span><span style=display:flex><span>        count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> next : graph<span style=color:#ff79c6>[</span>cur<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            indegree<span style=color:#ff79c6>[</span>next<span style=color:#ff79c6>]--</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (indegree<span style=color:#ff79c6>[</span>next<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>                q.<span style=color:#50fa7b>offer</span>(next);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (count <span style=color:#ff79c6>!=</span> numCourses) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 存在环，拓扑排序不存在</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{};
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=1015-二分图>10.1.5 二分图</h2><h2 id=1016-pirm算法和kruskal算法>10.1.6 Pirm算法和Kruskal算法</h2><h3 id=pirm算法模板>Pirm算法模板</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>Prim</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 核心数据结构，存储「横切边」的优先级队列</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> PriorityQueue<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;</span> pq;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[]</span> inMST;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 记录最小生成树的权重和</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> weightSum <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// graph 是用邻接表表示的一幅图，</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// graph[s] 记录节点 s 所有相邻的边，</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 三元组 int[]{from, to, weight} 表示一条边</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> List<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;[]</span> graph;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>Prim</span>(List<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;[]</span> graph) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>graph</span> <span style=color:#ff79c6>=</span> graph;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>pq</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PriorityQueue<span style=color:#ff79c6>&lt;&gt;</span>((a, b) <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 按照边的权重从小到大排序</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> a<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> b<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 图中有 n 个节点</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> graph.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>inMST</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 随便从一个点开始切分都可以，我们不妨从节点 0 开始</span>
</span></span><span style=display:flex><span>        inMST<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        cut(0);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 不断进行切分，向最小生成树中添加边</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>pq.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> edge <span style=color:#ff79c6>=</span> pq.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> to <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> weight <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (inMST<span style=color:#ff79c6>[</span>to<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 节点 to 已经在最小生成树中，跳过</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 否则这条边会产生环</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 将边 edge 加入最小生成树</span>
</span></span><span style=display:flex><span>            weightSum <span style=color:#ff79c6>+=</span> weight;
</span></span><span style=display:flex><span>            inMST<span style=color:#ff79c6>[</span>to<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 节点 to 加入后，进行新一轮切分，会产生更多横切边</span>
</span></span><span style=display:flex><span>            cut(to);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将 s 的横切边加入优先队列</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>cut</span>(<span style=color:#8be9fd>int</span> s) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 遍历 s 的邻边</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> edge : graph<span style=color:#ff79c6>[</span>s<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> to <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (inMST<span style=color:#ff79c6>[</span>to<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 相邻接点 to 已经在最小生成树中，跳过</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 否则这条边会产生环</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 加入横切边队列</span>
</span></span><span style=display:flex><span>            pq.<span style=color:#50fa7b>offer</span>(edge);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 最小生成树的权重和</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>weightSum</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> weightSum;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断最小生成树是否包含图中的所有节点</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>allConnected</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> inMST.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>inMST<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=kruskal算法模板>Kruskal算法模板</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>Kruskal</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>minimumCost</span>(<span style=color:#8be9fd>int</span> n, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> connections) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 城市编号为 1...n，所以初始化大小为 n + 1</span>
</span></span><span style=display:flex><span>        UF uf <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UF(n <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 对所有边按照权重从小到大排序</span>
</span></span><span style=display:flex><span>        Arrays.<span style=color:#50fa7b>sort</span>(connections, (a, b) <span style=color:#ff79c6>-&gt;</span> (a<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> b<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 记录最小生成树的权重之和</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> mst <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> edge : connections) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> u <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> v <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> weight <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 若这条边会产生环，则不能加入 mst</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (uf.<span style=color:#50fa7b>isSame</span>(u, v)) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 若这条边不会产生环，则属于最小生成树</span>
</span></span><span style=display:flex><span>            mst <span style=color:#ff79c6>+=</span> weight;
</span></span><span style=display:flex><span>            uf.<span style=color:#50fa7b>join</span>(u, v);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 保证所有节点都被连通</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 按理说 uf.count() == 1 说明所有节点被连通</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 但因为节点 0 没有被使用，所以 0 会额外占用一个连通分量</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> uf.<span style=color:#50fa7b>count</span>() <span style=color:#ff79c6>==</span> 2 <span style=color:#ff79c6>?</span> mst : <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>UF</span> {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> count;  <span style=color:#6272a4>// 连通分量个数</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> father;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>UF</span>(<span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>count</span> <span style=color:#ff79c6>=</span> n;
</span></span><span style=display:flex><span>            father <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> n; <span style=color:#ff79c6>++</span>i) {
</span></span><span style=display:flex><span>                father<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 并查集里寻根的过程</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>find</span>(<span style=color:#8be9fd>int</span> u) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>return</span> u;
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 路径压缩</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>return</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> find(father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 判断 u 和 v是否找到同一个根</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSame</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>            u <span style=color:#ff79c6>=</span> find(u);
</span></span><span style=display:flex><span>            v <span style=color:#ff79c6>=</span> find(v);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> u <span style=color:#ff79c6>==</span> v;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 将v-&gt;u 这条边加入并查集</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>join</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>            u <span style=color:#ff79c6>=</span> find(u); <span style=color:#6272a4>// 寻找u的根</span>
</span></span><span style=display:flex><span>            v <span style=color:#ff79c6>=</span> find(v); <span style=color:#6272a4>// 寻找v的根</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> v) <span style=color:#ff79c6>return</span>; <span style=color:#6272a4>// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span>
</span></span><span style=display:flex><span>            father<span style=color:#ff79c6>[</span>v<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> u;
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>--</span>;  <span style=color:#6272a4>// 两个连通分量合并成一个连通分量</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 返回图中的连通分量个数</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>count</span>() {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> count;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=1017-dijkstra算法>10.1.7 Dijkstra算法</h2><h3 id=dijkstra算法模板>Dijkstra算法模板</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>Dijkstra</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * Dijkstra 算法
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 根据labuladong修改，可能存在错误
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>State</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 图节点的 id</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> id;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 从 start 节点到当前节点的距离</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> distFromStart;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        State(<span style=color:#8be9fd>int</span> id, <span style=color:#8be9fd>int</span> distFromStart) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>id</span> <span style=color:#ff79c6>=</span> id;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>distFromStart</span> <span style=color:#ff79c6>=</span> distFromStart;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>dijkstra</span>(<span style=color:#8be9fd>int</span> start, List<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;[]</span> graph) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 图中节点的个数</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> V <span style=color:#ff79c6>=</span> graph.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 记录最短路径的权重，你可以理解为 dp table</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> distTo <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>V<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 求最小值，所以 dp table 初始化为正无穷</span>
</span></span><span style=display:flex><span>        Arrays.<span style=color:#50fa7b>fill</span>(distTo, Integer.<span style=color:#50fa7b>MAX_VALUE</span>);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// base case，start 到 start 的最短距离就是 0</span>
</span></span><span style=display:flex><span>        distTo<span style=color:#ff79c6>[</span>start<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 优先级队列，distFromStart 较小的排在前面</span>
</span></span><span style=display:flex><span>        PriorityQueue<span style=color:#ff79c6>&lt;</span>State<span style=color:#ff79c6>&gt;</span> pq <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PriorityQueue<span style=color:#ff79c6>&lt;&gt;</span>((a, b) <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> a.<span style=color:#50fa7b>distFromStart</span> <span style=color:#ff79c6>-</span> b.<span style=color:#50fa7b>distFromStart</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 从起点 start 开始进行 BFS</span>
</span></span><span style=display:flex><span>        pq.<span style=color:#50fa7b>offer</span>(<span style=color:#ff79c6>new</span> State(start, 0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>pq.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>            State curState <span style=color:#ff79c6>=</span> pq.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> curNodeID <span style=color:#ff79c6>=</span> curState.<span style=color:#50fa7b>id</span>;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> curDistFromStart <span style=color:#ff79c6>=</span> curState.<span style=color:#50fa7b>distFromStart</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (curDistFromStart <span style=color:#ff79c6>&gt;</span> distTo<span style=color:#ff79c6>[</span>curNodeID<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 已经有一条更短的路径到达 curNode 节点了</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 将 curNode 的相邻节点装入队列</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> edge : graph<span style=color:#ff79c6>[</span>curNodeID<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> nextNodeID <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> weight <span style=color:#ff79c6>=</span> edge<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 看看从 curNode 达到 nextNode 的距离是否会更短</span>
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> distToNextNode <span style=color:#ff79c6>=</span> distTo<span style=color:#ff79c6>[</span>curNodeID<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> weight;  <span style=color:#6272a4>//weight(curNodeID, nextNodeID);</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (distTo<span style=color:#ff79c6>[</span>nextNodeID<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> distToNextNode) {
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 更新 dp table</span>
</span></span><span style=display:flex><span>                    distTo<span style=color:#ff79c6>[</span>nextNodeID<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> distToNextNode;
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 将这个节点以及距离放入队列</span>
</span></span><span style=display:flex><span>                    pq.<span style=color:#50fa7b>offer</span>(<span style=color:#ff79c6>new</span> State(nextNodeID, distToNextNode));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> distTo;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=102-重点题目及出错的题目等>10.2 重点题目及出错的题目等</h2><h3 id=200-岛屿数量httpsleetcodecnproblemsnumber-of-islands模板题><a href=https://leetcode.cn/problems/number-of-islands/>200. 岛屿数量</a>（模板题）</h3><h4 id=深搜法>深搜法</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dir <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        {0,1},{1,0},{<span style=color:#ff79c6>-</span>1,0},{0,<span style=color:#ff79c6>-</span>1}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>numIslands</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> grid) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m  <span style=color:#ff79c6>=</span> grid.<span style=color:#50fa7b>length</span>;;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>m<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;1&#39;</span>) {
</span></span><span style=display:flex><span>                visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                res<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                dfs(grid,visited,i,j);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dfs</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> grid, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited, <span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 4; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nextx <span style=color:#ff79c6>=</span> x <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nexty <span style=color:#ff79c6>=</span> y <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nextx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nextx <span style=color:#ff79c6>&gt;=</span> grid.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&gt;=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;1&#39;</span>) {
</span></span><span style=display:flex><span>            visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>            dfs(grid, visited, nextx, nexty);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=广搜法>广搜法</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dir <span style=color:#ff79c6>=</span> {{0, 1}, {0, <span style=color:#ff79c6>-</span>1}, {1, 0}, {<span style=color:#ff79c6>-</span>1, 0}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>numIslands</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> grid) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>grid.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> grid.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span>(<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;1&#39;</span>) {
</span></span><span style=display:flex><span>                res<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                bfs(grid,visited, i, j);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//将这片岛屿上的所有陆地都访问到</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>bfs</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> grid, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited, <span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y) {
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;</span> queue <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    queue.<span style=color:#50fa7b>offer</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{x, y});
</span></span><span style=display:flex><span>    visited<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>y<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span>(<span style=color:#ff79c6>!</span>queue.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> cur <span style=color:#ff79c6>=</span> queue.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> curx <span style=color:#ff79c6>=</span> cur<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> cury <span style=color:#ff79c6>=</span> cur<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 4; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> nextx <span style=color:#ff79c6>=</span> curx <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> nexty <span style=color:#ff79c6>=</span> cury <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span>(nextx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nextx <span style=color:#ff79c6>&gt;=</span> grid.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&gt;=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span>(<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;1&#39;</span>) {
</span></span><span style=display:flex><span>                queue.<span style=color:#50fa7b>offer</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{nextx, nexty});
</span></span><span style=display:flex><span>                visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>; <span style=color:#6272a4>//只要加入队列就标记为访问</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=7-飞地的数量httpsprogrammercarlcom1020飞地的数量html><a href=https://programmercarl.com/1020.%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F.html>7. 飞地的数量</a></h3><p>本题要求找到不靠边的陆地面积，那么我们只要从周边找到陆地然后 通过 dfs或者bfs 将周边靠陆地且相邻的陆地都变成海洋，然后再去重新遍历地图的时候，统计此时还剩下的陆地就可以了。</p><p>所以当我们遍历过程中就需要淹没陆地，即将<code>grid[i][j]=0;</code></p><h3 id=9-太平洋大西洋水流问题httpsprogrammercarlcom0417太平洋大西洋水流问题html><a href=https://programmercarl.com/0417.%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html>9. 太平洋大西洋水流问题</a></h3><p>从太平洋边上的节点 逆流而上，将遍历过的节点都标记上。 从大西洋的边上节点 逆流而长，将遍历过的节点也标记上。 然后两方都标记过的节点就是既可以流太平洋也可以流大西洋的节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dir <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        {0,1},{0,<span style=color:#ff79c6>-</span>1},{1,0},{<span style=color:#ff79c6>-</span>1,0}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#50fa7b>pacificAtlantic</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> heights) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m <span style=color:#ff79c6>=</span> heights.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> heights<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> isPac <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>m<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> isAtl <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>m<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;&gt;</span> res <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dfs(heights,isPac,i,0);
</span></span><span style=display:flex><span>        dfs(heights,isAtl,i,n<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> n; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dfs(heights,isPac,0,i);
</span></span><span style=display:flex><span>        dfs(heights,isAtl,m<span style=color:#ff79c6>-</span>1,i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (isPac<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> isAtl<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>) res.<span style=color:#50fa7b>add</span>(List.<span style=color:#50fa7b>of</span>(i,j));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dfs</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> height, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited, <span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (visited<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>y<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    visited<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>y<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 4; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nextx <span style=color:#ff79c6>=</span> x <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nexty <span style=color:#ff79c6>=</span> y <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nextx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nextx <span style=color:#ff79c6>&gt;=</span> height.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&gt;=</span> height<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (height<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>y<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> height<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        dfs(height,visited,nextx,nexty);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=10-最大人工岛httpsprogrammercarlcom0827最大人工岛html><a href=https://programmercarl.com/0827.%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B.html>10. 最大人工岛</a></h3><p>只要用一次深搜把每个岛屿的面积记录下来就好。</p><p>第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积 第二步：在遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。</p><ul><li>第一步：</li></ul><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-13_14-55-47.png alt></p><ul><li>第二步：</li></ul><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-13_14-56-28.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dir <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        {1,0},{<span style=color:#ff79c6>-</span>1,0},{0,1},{0,<span style=color:#ff79c6>-</span>1}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> count;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>largestIsland</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> grid) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m <span style=color:#ff79c6>=</span> grid.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>m<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> mark <span style=color:#ff79c6>=</span> 2;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> isAllGrid <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    HashMap<span style=color:#ff79c6>&lt;</span>Integer,Integer<span style=color:#ff79c6>&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) isAllGrid <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&amp;&amp;</span> grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 1) {
</span></span><span style=display:flex><span>                count <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>                visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> mark;
</span></span><span style=display:flex><span>                dfs(grid,visited,i,j,mark);
</span></span><span style=display:flex><span>                map.<span style=color:#50fa7b>put</span>(mark,count);
</span></span><span style=display:flex><span>                mark<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (isAllGrid) <span style=color:#ff79c6>return</span> m<span style=color:#ff79c6>*</span>n;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    HashSet<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> set <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> sum <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>            set.<span style=color:#50fa7b>clear</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> k <span style=color:#ff79c6>=</span> 0; k <span style=color:#ff79c6>&lt;</span> 4; k<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>int</span> nextx <span style=color:#ff79c6>=</span> i <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>k<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>int</span> nexty <span style=color:#ff79c6>=</span> j <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>k<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>if</span> (nextx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nextx <span style=color:#ff79c6>&gt;=</span> grid.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&gt;=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>if</span> (map.<span style=color:#50fa7b>containsKey</span>(grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>set.<span style=color:#50fa7b>contains</span>(grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span>)){
</span></span><span style=display:flex><span>                        sum <span style=color:#ff79c6>+=</span> map.<span style=color:#50fa7b>get</span>(grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>                        set.<span style=color:#50fa7b>add</span>(grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(res,sum);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dfs</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> grid, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited, <span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y, <span style=color:#8be9fd>int</span> mark){
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 4; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nextx <span style=color:#ff79c6>=</span> x <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nexty <span style=color:#ff79c6>=</span> y <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nextx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nextx <span style=color:#ff79c6>&gt;=</span> grid.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&gt;=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 1) {
</span></span><span style=display:flex><span>            visited<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>            grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> mark;
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            dfs(grid,visited,nextx,nexty,mark);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=11-单词接龙httpsprogrammercarlcom0127单词接龙html><a href=https://programmercarl.com/0127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.html>11. 单词接龙</a></h3><p>本题只需要求出最短路径的长度就可以了，不用找出路径。</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-13_15-41-51.png alt></p><p>所以这道题要解决两个问题：</p><ul><li>图中的线是如何连在一起的</li><li>起点和终点的最短路径长度</li></ul><p>首先题目中并没有给出点与点之间的连线，而是要我们自己去连，条件是字符只能差一个，所以判断点与点之间的关系，要自己判断是不是差一个字符，如果差一个字符，那就是有链接。</p><p>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p><p>另外需要有一个注意点：</p><ul><li>本题是一个无向图，需要用标记位，标记着节点是否走过，否则就会死循环！</li><li>本题给出集合是数组型的，可以转成set结构，查找更快一些</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>ladderLength</span>(String beginWord, String endWord, List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> wordList) {
</span></span><span style=display:flex><span>    HashSet<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> wordSet <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;</span>(wordList); <span style=color:#6272a4>//转换为hashset 加快速度</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (wordSet.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>==</span> 0 <span style=color:#ff79c6>||</span> <span style=color:#ff79c6>!</span>wordSet.<span style=color:#50fa7b>contains</span>(endWord)) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> deque <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    HashMap<span style=color:#ff79c6>&lt;</span>String, Integer<span style=color:#ff79c6>&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    deque.<span style=color:#50fa7b>offer</span>(beginWord);
</span></span><span style=display:flex><span>    map.<span style=color:#50fa7b>put</span>(beginWord,1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        String word <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> path <span style=color:#ff79c6>=</span> map.<span style=color:#50fa7b>get</span>(word);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> word.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> words <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>toCharArray</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>char</span> k <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;a&#39;</span>; k <span style=color:#ff79c6>&lt;=</span> <span style=color:#f1fa8c>&#39;z&#39;</span>; k<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>                words<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> k;
</span></span><span style=display:flex><span>                String newWord <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> String(words);
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (newWord.<span style=color:#50fa7b>equals</span>(endWord)) <span style=color:#ff79c6>return</span> path<span style=color:#ff79c6>+</span>1;
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>wordSet.<span style=color:#50fa7b>contains</span>(newWord) <span style=color:#ff79c6>||</span> map.<span style=color:#50fa7b>containsKey</span>(newWord)) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>                map.<span style=color:#50fa7b>put</span>(newWord,path<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>                deque.<span style=color:#50fa7b>offer</span>(newWord);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=17-冗余连接iihttpsprogrammercarlcom0685冗余连接iihtml><a href=https://programmercarl.com/0685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html>17. 冗余连接II</a></h3><p>那么有如下三种情况，前两种情况是出现入度为2的点，如图：</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-13_20-44-06.png alt></p><p>对于情况1和情况2需要先统计入度为2点节点的边，然后再判断删除后是否是一棵树（即如果连通说明不是），之后决定删除哪个边。</p><p>第三种情况是没有入度为2的点，那么图中一定出现了有向环（<strong>注意这里强调是有向环！</strong>）</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-13_20-45-58.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> father <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>1001<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> father.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        father<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>find</span>(<span style=color:#8be9fd>int</span> u) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>return</span> u;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>return</span> father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> find(father<span style=color:#ff79c6>[</span>u<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isSame</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>    u <span style=color:#ff79c6>=</span> find(u);
</span></span><span style=display:flex><span>    v <span style=color:#ff79c6>=</span> find(v);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> u <span style=color:#ff79c6>==</span> v;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>join</span>(<span style=color:#8be9fd>int</span> u, <span style=color:#8be9fd>int</span> v) {
</span></span><span style=display:flex><span>    u <span style=color:#ff79c6>=</span> find(u);
</span></span><span style=display:flex><span>    v <span style=color:#ff79c6>=</span> find(v);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (u <span style=color:#ff79c6>==</span> v) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    father<span style=color:#ff79c6>[</span>v<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> u;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>findRedundantDirectedConnection</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> edges) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> inDegree <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>1001<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> edges.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        inDegree<span style=color:#ff79c6>[</span>edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]]++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> list <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> edges.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>-</span>1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (inDegree<span style=color:#ff79c6>[</span>edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>==</span> 2) {
</span></span><span style=display:flex><span>            list.<span style=color:#50fa7b>add</span>(i);  <span style=color:#6272a4>//记录当前入度为2的节点</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (list.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (isTreeAfterRemoveEdge(edges,list.<span style=color:#50fa7b>get</span>(0))) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> edges<span style=color:#ff79c6>[</span>list.<span style=color:#50fa7b>get</span>(0)<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> edges<span style=color:#ff79c6>[</span>list.<span style=color:#50fa7b>get</span>(1)<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> getRemoveEdge(edges);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isTreeAfterRemoveEdge</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> edges, Integer deleteEdge) {
</span></span><span style=display:flex><span>    init();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> edges.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>==</span> deleteEdge) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (isSame(edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>,edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }<span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            join(edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>,edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>getRemoveEdge</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> edges) {
</span></span><span style=display:flex><span>    init();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> edges.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (isSame(edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>, edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            join(edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>, edges<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=11--贪心>11. 贪心</h1><h2 id=111-做题总结与技巧>11.1 做题总结与技巧</h2><h3 id=重叠区间问题>重叠区间问题</h3><p><strong>首先要确定一个维度，之后排序后再去根据另一个维度进行判断。<a href=https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html>14. 根据身高重建队列</a></strong></p><p><a href=https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html>17. 用最少数量的箭引爆气球</a></p><p><a href=https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html>18. 无重叠区间</a></p><p><a href=https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html>19. 划分字母区间</a></p><p><a href=https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html>20. 合并区间</a></p><h3 id=贪心算法总结篇httpsprogrammercarlcom贪心算法总结篇html><a href=https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87.html>贪心算法总结篇</a></h3><h2 id=112--重点题目及出错的题目等>11.2 重点题目及出错的题目等</h2><h3 id=3-摆动序列httpsprogrammercarlcom0376摆动序列html><a href=https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html>3. 摆动序列</a></h3><p>找两个峰值，一个山谷，一个山顶。</p><p>在计算是否有峰值的时候，大家知道遍历的下标 i ，计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果<code>prediff &lt; 0 && curdiff > 0</code> 或者 <code>prediff > 0 && curdiff &lt; 0</code> 此时就有波动就需要统计。</p><p>这是我们思考本题的一个大题思路，但本题要考虑三种情况：</p><ul><li>情况一：上下坡中有平坡</li></ul><p>所以我们记录峰值的条件应该是： <code>(preDiff &lt;= 0 && curDiff > 0) || (preDiff >= 0 && curDiff &lt; 0)</code>，为什么这里允许 prediff == 0 ，就是为了 上面我说的这种情况。</p><ul><li>情况二：数组首尾两端</li></ul><p>result 初始为 1（默认最右面有一个峰值）</p><ul><li>情况三：单调坡中有平坡</li></ul><p>我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>wiggleMaxLength</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>&lt;=</span> 1) <span style=color:#ff79c6>return</span> nums.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> pre <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> cur <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        cur <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> ((pre <span style=color:#ff79c6>&lt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> cur <span style=color:#ff79c6>&gt;</span> 0) <span style=color:#ff79c6>||</span> (pre <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> cur <span style=color:#ff79c6>&lt;</span> 0)) {
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            pre <span style=color:#ff79c6>=</span> cur; <span style=color:#6272a4>// 注意这里，只在摆动变化的时候更新pre</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=7-跳跃游戏httpsprogrammercarlcom0055跳跃游戏html><a href=https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html>7. 跳跃游戏</a></h3><p>考虑<strong>可以跳跃的覆盖范围。</strong></p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-14_09-07-49.png alt></p><p>i 每次移动只能在 cover 的范围内移动，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。</p><p>而 cover 每次只取 max(该元素数值补充后的范围, cover 本身范围)。</p><p>如果 cover 大于等于了终点下标，直接 return true 就可以了。</p><h3 id=8-跳跃游戏iihttpsprogrammercarlcom0045跳跃游戏iihtml><a href=https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html>8. 跳跃游戏II</a></h3><p>理解本题的关键在于：<strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点</strong>，这个范围内最少步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p><p><strong>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong>。</p><p>移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。</p><p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p><ul><li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li><li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>jump</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> 1) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> curDistance <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> nextDistance <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        nextDistance <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(nextDistance,i<span style=color:#ff79c6>+</span>nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (curDistance <span style=color:#ff79c6>==</span> i){
</span></span><span style=display:flex><span>            ans<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            curDistance <span style=color:#ff79c6>=</span> nextDistance;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (curDistance <span style=color:#ff79c6>&gt;=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1) <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=11-加油站httpsprogrammercarlcom0134加油站html><a href=https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html>11. 加油站</a></h3><p>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</p><p><strong>那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><h3 id=12-分发糖果httpsprogrammercarlcom0135分发糖果html><a href=https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html>12. 分发糖果</a></h3><p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p><p>那么本题我采用了两次贪心的策略：</p><ul><li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li><li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li></ul><p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p><strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>candy</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> ratings) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> candyVec <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>ratings.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>fill</span>(candyVec,1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> ratings.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (ratings<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> ratings<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) candyVec<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> candyVec<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> ratings.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 2;  i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (ratings<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> ratings<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            candyVec<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(candyVec<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,candyVec<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]+</span>1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> Arrays.<span style=color:#50fa7b>stream</span>(candyVec).<span style=color:#50fa7b>sum</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=14-根据身高重建队列httpsprogrammercarlcom0406根据身高重建队列html><a href=https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html>14. 根据身高重建队列</a></h3><p><strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p><p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p><p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p><p>只需要按照k为下标重新插入队列就可以了。</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-14_11-10-15.png alt></p><p>此外，插入的时候可以选择LinkedList，其中的list.add(index,elemrnt)插入元素很便捷。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> <span style=color:#50fa7b>reconstructQueue</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> people) {
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(people,(o1, o2) <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (o1<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> o2<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> o1<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> o2<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> o2<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> o1<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    LinkedList<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;</span> list <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> person : people) {
</span></span><span style=display:flex><span>        list.<span style=color:#50fa7b>add</span>(person<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>,person);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> list.<span style=color:#50fa7b>toArray</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>people.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][]</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=18-无重叠区间httpsprogrammercarlcom0435无重叠区间html><a href=https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html>18. 无重叠区间</a></h3><p>主要就是为了让区间尽可能的重叠。</p><p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>此时问题就是要求非交叉区间的最大个数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>eraseOverlapIntervals</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> intervals) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (intervals.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> 1) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(intervals, (o1, o2) <span style=color:#ff79c6>-&gt;</span> Integer.<span style=color:#50fa7b>compare</span>(o1<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>,o2<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> end <span style=color:#ff79c6>=</span> intervals<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> intervals.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (end <span style=color:#ff79c6>&lt;=</span> intervals<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            end <span style=color:#ff79c6>=</span> intervals<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> intervals.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=19-划分字母区间httpsprogrammercarlcom0763划分字母区间html><a href=https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html>19. 划分字母区间</a></h3><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>partitionLabels</span>(String s) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> hash <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>26<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//统计每个字符最后出现的位置</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        hash<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span><span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        right <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(right, hash<span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span><span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>==</span> right) {
</span></span><span style=display:flex><span>            ans.<span style=color:#50fa7b>add</span>(right <span style=color:#ff79c6>-</span> left <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>            left <span style=color:#ff79c6>=</span> i<span style=color:#ff79c6>+</span>1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=20-合并区间httpsprogrammercarlcom0056合并区间html><a href=https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html>20. 合并区间</a></h3><p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt;= intervals[i - 1][1]</code> 即intervals[i]的左边界 &lt;= intervals[i - 1]的右边界，则一定有重叠。（本题相邻区间也算重贴，所以是&lt;=）</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> <span style=color:#50fa7b>merge</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> intervals) {
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(intervals,(o1, o2) <span style=color:#ff79c6>-&gt;</span> Integer.<span style=color:#50fa7b>compare</span>(o1<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>,o2<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>    LinkedList<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;</span> list <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    list.<span style=color:#50fa7b>add</span>(intervals<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> intervals.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (intervals<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;=</span> list.<span style=color:#50fa7b>getLast</span>()<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            list.<span style=color:#50fa7b>getLast</span>()<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(list.<span style=color:#50fa7b>getLast</span>()<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>,intervals<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            list.<span style=color:#50fa7b>add</span>(intervals<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> list.<span style=color:#50fa7b>toArray</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>list.<span style=color:#50fa7b>size</span>()<span style=color:#ff79c6>][]</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=23-监控二叉树httpsprogrammercarlcom0968监控二叉树html><a href=https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html>23. 监控二叉树</a></h3><p><strong>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p><p>此时这道题目还有两个难点：</p><ul><li>二叉树的遍历</li></ul><p>要从叶子节点向根遍历，需要后序遍历</p><ul><li>如何隔两个节点放一个摄像头</li></ul><p>在后序遍历过程中返回值来表示当前节点的状态，有以下三种：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p>其中空节点设置为2有覆盖状态，防止叶子节点占用摄像头。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (node <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 2;
</span></span></code></pre></div><p>主要有如下四类情况：</p><ul><li>情况1：左右节点都有覆盖</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> 2 <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>==</span> 2) <span style=color:#ff79c6>return</span> 0;
</span></span></code></pre></div><ul><li>情况2：左右节点至少有一个无覆盖的情况</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> 0 <span style=color:#ff79c6>||</span> right <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>    ans<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> 1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>情况3：左右节点至少有一个有摄像头</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> 1 <span style=color:#ff79c6>||</span> right <span style=color:#ff79c6>==</span> 1) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> 2;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>情况4：头结点没有覆盖</li></ul><p>递归结束后要判断是否头结点有没有覆盖。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (traversal(root) <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>    ans<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>完整代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 0：该节点无覆盖
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 1：本节点有摄像头
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 2：本节点有覆盖
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>minCameraCover</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (traversal(root) <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>        ans<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>traversal</span>(TreeNode node) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (node <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 2;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> traversal(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> traversal(node.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> 2 <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>==</span> 2) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> 0 <span style=color:#ff79c6>||</span> right <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>        ans<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> 1 <span style=color:#ff79c6>||</span> right <span style=color:#ff79c6>==</span> 1) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> 2;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=贪心dota2参议院httpsprogrammercarlcom0649dota2参议院html><a href=https://programmercarl.com/0649.Dota2%E5%8F%82%E8%AE%AE%E9%99%A2.html>贪心：Dota2参议院</a></h3><p><strong>其实这是一个持续消灭的过程！</strong> 即：如果同时存在R和D就继续进行下一轮消灭，轮数直到只剩下R或者D为止！</p><p><strong>所以消灭的策略是，尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴！</strong></p><p>实现代码，在每一轮循环的过程中，去过模拟优先消灭身后的对手，其实是比较麻烦的。</p><p><strong>这里有一个技巧，就是用一个变量记录当前参议员之前有几个敌对对手了，进而判断自己是否被消灭了。这个变量我用flag来表示。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> String <span style=color:#50fa7b>predictPartyVictory</span>(String senate) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>char</span><span style=color:#ff79c6>[]</span> chars <span style=color:#ff79c6>=</span> senate.<span style=color:#50fa7b>toCharArray</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> R <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;  <span style=color:#6272a4>//是否还存在R</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> D <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;   <span style=color:#6272a4>//是否还存在D</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> flag <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (R <span style=color:#ff79c6>&amp;&amp;</span> D) {   <span style=color:#6272a4>//轮次</span>
</span></span><span style=display:flex><span>        R <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        D <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> chars.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {  <span style=color:#6272a4>//单轮逻辑</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (chars<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;R&#39;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (flag <span style=color:#ff79c6>&lt;</span> 0) chars<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>else</span> R <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                flag<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (chars<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;D&#39;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (flag <span style=color:#ff79c6>&gt;</span> 0) chars<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>else</span> D <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                flag<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> R <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>true</span> <span style=color:#ff79c6>?</span> <span style=color:#f1fa8c>&#34;Radiant&#34;</span> : <span style=color:#f1fa8c>&#34;Dire&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=12-other>12. Other</h1><h2 id=前缀和>前缀和</h2><p><a href=https://blog.csdn.net/fuxuemingzhu/article/details/120132922>https://blog.csdn.net/fuxuemingzhu/article/details/120132922</a></p><p><strong>总之，如果题目要求「区间和」的时候，那么就可以考虑使用「前缀和」。</strong></p><h3 id=模板题304-二维区域和检索---矩阵不可变httpsleetcodecnproblemsrange-sum-query-2d-immutable>模板题：<a href=https://leetcode.cn/problems/range-sum-query-2d-immutable/>304. 二维区域和检索 - 矩阵不可变</a></h3><h4 id=二维前缀和模板>二维前缀和模板</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>NumMatrix</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> preSum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>NumMatrix</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> matrix) {
</span></span><span style=display:flex><span>        preSum <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>matrix.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>][</span>matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> matrix.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>           <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>               preSum<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> preSum<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> preSum<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> preSum<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>sumRegion</span>(<span style=color:#8be9fd>int</span> row1, <span style=color:#8be9fd>int</span> col1, <span style=color:#8be9fd>int</span> row2, <span style=color:#8be9fd>int</span> col2) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> preSum<span style=color:#ff79c6>[</span>row2 <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>][</span>col2 <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> preSum<span style=color:#ff79c6>[</span>row2 <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>][</span>col1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> preSum<span style=color:#ff79c6>[</span>row1<span style=color:#ff79c6>][</span>col2 <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> preSum<span style=color:#ff79c6>[</span>row1<span style=color:#ff79c6>][</span>col1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=一维前缀和模板>一维前缀和模板</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>NumMatrix</span> {
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> preSum;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>NumMatrix</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> matrix) {
</span></span><span style=display:flex><span>       	preSum <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>matrix.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> matrix.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>             preSum<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> preSum<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>sumRegion</span>(<span style=color:#8be9fd>int</span> i, <span style=color:#8be9fd>int</span> j) {
</span></span><span style=display:flex><span>    	<span style=color:#ff79c6>return</span> preSum<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> preSum<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=122--其它题目>12.2 其它题目</h2><h3 id=模拟下一个排列httpsprogrammercarlcom0031下一个排列html><a href=https://programmercarl.com/0031.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97.html>模拟：下一个排列</a></h3><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-15_15-30-19.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>nextPermutation</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1; j <span style=color:#ff79c6>&gt;</span> i ; j<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> tmp <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                nums<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>                Arrays.<span style=color:#50fa7b>sort</span>(nums,i<span style=color:#ff79c6>+</span>1,nums.<span style=color:#50fa7b>length</span>);
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(nums); <span style=color:#6272a4>// 不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=位运算根据数字二进制下1的数目排序httpsprogrammercarlcom1356根据数字二进制下1的数目排序html><a href=https://programmercarl.com/1356.%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F.html>位运算：根据数字二进制下1的数目排序</a></h3><p>通过n&(n-1)可以清除最低位的1，从而计算出包含多少个1。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> <span style=color:#50fa7b>sortByBits</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> Arrays.<span style=color:#50fa7b>stream</span>(arr).<span style=color:#50fa7b>boxed</span>().<span style=color:#50fa7b>sorted</span>(<span style=color:#ff79c6>new</span> Comparator<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>() {
</span></span><span style=display:flex><span>        @Override
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>compare</span>(Integer o1, Integer o2) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> count1 <span style=color:#ff79c6>=</span> CalBit(o1);
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> count2 <span style=color:#ff79c6>=</span> CalBit(o2);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (count1 <span style=color:#ff79c6>==</span> count2) <span style=color:#ff79c6>return</span> Integer.<span style=color:#50fa7b>compare</span>(o1,o2);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> Integer.<span style=color:#50fa7b>compare</span>(count1,count2);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }).<span style=color:#50fa7b>mapToInt</span>(Integer::intValue).<span style=color:#50fa7b>toArray</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>CalBit</span>(<span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (n <span style=color:#ff79c6>==</span> 0) <span style=color:#ff79c6>return</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (n <span style=color:#ff79c6>!=</span> 0) {
</span></span><span style=display:flex><span>        n <span style=color:#ff79c6>&amp;=</span> (n<span style=color:#ff79c6>-</span>1);  <span style=color:#6272a4>//清除最低位的1</span>
</span></span><span style=display:flex><span>        count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=名流问题>名流问题</h3><h4 id=问题描述>问题描述：</h4><p>给你 <code>n</code> 个人的社交关系（你知道任意两个人之间是否认识），然后请你找出这些人中的「名人」。</p><p>所谓「名人」有两个条件：</p><p>1、所有其他人都认识「名人」。</p><p>2、「名人」不认识任何其他人。</p><h4 id=解决>解决：</h4><p><strong>我们可以不断从候选人中选两个出来，然后排除掉一个，直到最后只剩下一个候选人，这时候再使用一个 for 循环判断这个候选人是否是货真价实的「名人」</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>findCelebrity</span>(<span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 先假设 cand 是名人</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> cand <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> other <span style=color:#ff79c6>=</span> 1; other <span style=color:#ff79c6>&lt;</span> n; other<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>knows(other, cand) <span style=color:#ff79c6>||</span> knows(cand, other)) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// cand 不可能是名人，排除</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 假设 other 是名人</span>
</span></span><span style=display:flex><span>            cand <span style=color:#ff79c6>=</span> other;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// other 不可能是名人，排除</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 什么都不用做，继续假设 cand 是名人</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 现在的 cand 是排除的最后结果，但不能保证一定是名人</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> other <span style=color:#ff79c6>=</span> 0; other <span style=color:#ff79c6>&lt;</span> n; other<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (cand <span style=color:#ff79c6>==</span> other) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 需要保证其他人都认识 cand，且 cand 不认识任何其他人</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>knows(other, cand) <span style=color:#ff79c6>||</span> knows(cand, other)) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> cand;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=二分答案进行搜索华为0124-code2>二分答案进行搜索(华为0124 code2)</h2><h2 id=树状数组华为0124-code3>树状数组(华为0124 code3)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>BIT</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> trees;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>BIT</span>(<span style=color:#8be9fd>int</span> n) {
</span></span><span style=display:flex><span>        trees <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>n <span style=color:#ff79c6>+</span> 1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>update</span>(<span style=color:#8be9fd>int</span> index, <span style=color:#8be9fd>int</span> val) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> index <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (i <span style=color:#ff79c6>&lt;</span> trees.<span style=color:#50fa7b>length</span>) {
</span></span><span style=display:flex><span>            trees<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+=</span> val;
</span></span><span style=display:flex><span>            i <span style=color:#ff79c6>+=</span> i <span style=color:#ff79c6>&amp;</span> <span style=color:#ff79c6>-</span>i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>query</span>(<span style=color:#8be9fd>int</span> x) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> cnt <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (x <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>            cnt <span style=color:#ff79c6>+=</span> trees<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            x <span style=color:#ff79c6>-=</span> x <span style=color:#ff79c6>&amp;</span> <span style=color:#ff79c6>-</span>x;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> cnt;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>queryRange</span>(<span style=color:#8be9fd>int</span> left, <span style=color:#8be9fd>int</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> query(right <span style=color:#ff79c6>+</span> 1) <span style=color:#ff79c6>-</span> query(left);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=13-hot100>13. Hot100</h1><h2 id=128-最长连续序列httpsleetcodecnproblemslongest-consecutive-sequence><a href=https://leetcode.cn/problems/longest-consecutive-sequence/>128. 最长连续序列</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 使用哈希表去重
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 找到没有num-1的，这就说明找到了连续数中的最小值
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 然后+1往大找连续数的个数
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>longestConsecutive</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> 0) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    HashSet<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> set <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> num : nums) {
</span></span><span style=display:flex><span>        set.<span style=color:#50fa7b>add</span>(num);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (Integer integer : set) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>set.<span style=color:#50fa7b>contains</span>(integer<span style=color:#ff79c6>-</span>1)) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> curNum <span style=color:#ff79c6>=</span> integer;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (set.<span style=color:#50fa7b>contains</span>(curNum<span style=color:#ff79c6>+</span>1)) {
</span></span><span style=display:flex><span>                curNum<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>                len<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ans <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(ans,len);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=11-盛最多水的容器httpsleetcodecnproblemscontainer-with-most-water><a href=https://leetcode.cn/problems/container-with-most-water/>11. 盛最多水的容器</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 双指针
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 每轮都计算
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 哪边小就移动
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param height
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>maxArea</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> height) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> height.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> hei <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(height<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>,height<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> right <span style=color:#ff79c6>-</span> left;
</span></span><span style=display:flex><span>        ans <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(ans,hei <span style=color:#ff79c6>*</span> len);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (height<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> height<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=560-和为-k-的子数组httpsleetcodecnproblemssubarray-sum-equals-k><a href=https://leetcode.cn/problems/subarray-sum-equals-k/>560. 和为 K 的子数组</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 前缀和+哈希表
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 说实话没太懂
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param k
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>subarraySum</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>    HashMap<span style=color:#ff79c6>&lt;</span>Integer,Integer<span style=color:#ff79c6>&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> pre <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    map.<span style=color:#50fa7b>put</span>(0,1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        pre <span style=color:#ff79c6>+=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (map.<span style=color:#50fa7b>containsKey</span>(pre <span style=color:#ff79c6>-</span> k)) {
</span></span><span style=display:flex><span>            ans <span style=color:#ff79c6>+=</span> map.<span style=color:#50fa7b>get</span>(pre <span style=color:#ff79c6>-</span> k);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        map.<span style=color:#50fa7b>put</span>(pre, map.<span style=color:#50fa7b>getOrDefault</span>(pre,0)<span style=color:#ff79c6>+</span>1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=41-缺失的第一个正数httpsleetcodecnproblemsfirst-missing-positive><a href=https://leetcode.cn/problems/first-missing-positive/>41. 缺失的第一个正数</a></h2><p>置换，将符合1-n的正数都换到他们对应的位置，然后判断位置上不等于的就是缺失的第一个正数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>firstMissingPositive</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;=</span> len <span style=color:#ff79c6>&amp;&amp;</span> nums<span style=color:#ff79c6>[</span>nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>!=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> tmp <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            nums<span style=color:#ff79c6>[</span>nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> len; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>!=</span> i<span style=color:#ff79c6>+</span>1) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> i<span style=color:#ff79c6>+</span>1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> len<span style=color:#ff79c6>+</span>1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=48-旋转图像httpsleetcodecnproblemsrotate-image><a href=https://leetcode.cn/problems/rotate-image/>48. 旋转图像</a></h2><p>先按中心线对折，再按对角线交换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>rotate</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> matrix) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> matrix.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> len <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> len; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> tmp <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>left<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>right<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>right<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> lenCol <span style=color:#ff79c6>=</span> len <span style=color:#ff79c6>-</span> 2;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;=</span> len <span style=color:#ff79c6>-</span> 2; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;=</span> lenCol; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> tmp <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>len <span style=color:#ff79c6>-</span> j <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>][</span>len <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            matrix<span style=color:#ff79c6>[</span>len <span style=color:#ff79c6>-</span> j <span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>len <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        lenCol<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=240-搜索二维矩阵-iihttpsleetcodecnproblemssearch-a-2d-matrix-ii><a href=https://leetcode.cn/problems/search-a-2d-matrix-ii/>240. 搜索二维矩阵 II</a></h2><p>二分查找类型</p><p>从右边和上边开始找，如果target大，那就往下找，如果target小，那就往左找。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>searchMatrix</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> matrix, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m <span style=color:#ff79c6>=</span> matrix.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> num <span style=color:#ff79c6>=</span> BinFind(matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,target);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (num <span style=color:#ff79c6>&lt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>num<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> target) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>BinFind</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> mid <span style=color:#ff79c6>=</span> left <span style=color:#ff79c6>+</span> (right <span style=color:#ff79c6>-</span> left) <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (target <span style=color:#ff79c6>==</span> nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> mid;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (target <span style=color:#ff79c6>&gt;</span> nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            left <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            right <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> right;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>searchMatrix2</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> matrix, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m <span style=color:#ff79c6>=</span> matrix.<span style=color:#50fa7b>length</span>, n <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> 0, y <span style=color:#ff79c6>=</span> n <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (x <span style=color:#ff79c6>&lt;</span> m <span style=color:#ff79c6>&amp;&amp;</span> y <span style=color:#ff79c6>&gt;=</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (matrix<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>y<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> target) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (matrix<span style=color:#ff79c6>[</span>x<span style=color:#ff79c6>][</span>y<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> target) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>--</span>y;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>++</span>x;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=21-合并两个有序链表httpsleetcodecnproblemsmerge-two-sorted-lists><a href=https://leetcode.cn/problems/merge-two-sorted-lists/>21. 合并两个有序链表</a></h2><p>方法一：递归，如果list1.val大的时候，就拿list2.val的做头，然后用list2.next和list1.val进行递归构建。</p><p>方法二：创建一个新的链表头，每次都next两者小的那个。</p><h2 id=25-k-个一组翻转链表httpsleetcodecnproblemsreverse-nodes-in-k-group><a href=https://leetcode.cn/problems/reverse-nodes-in-k-group/>25. K 个一组翻转链表</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ListNode <span style=color:#50fa7b>reverseKGroup</span>(ListNode head, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>    ListNode dummy <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ListNode(0);       <span style=color:#6272a4>// 此处只是设置一个哨兵节点</span>
</span></span><span style=display:flex><span>    dummy.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> head;      <span style=color:#6272a4>// 哨兵节点的下一个指向首节点</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode pre <span style=color:#ff79c6>=</span> dummy;       <span style=color:#6272a4>// 上一段的最后一个节点 节点初始化</span>
</span></span><span style=display:flex><span>    ListNode end <span style=color:#ff79c6>=</span> dummy;       <span style=color:#6272a4>// 本段最后一个节点</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (end.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 此处是为了找到其中的 k 个子节点</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0 ; i <span style=color:#ff79c6>&lt;</span> k <span style=color:#ff79c6>&amp;&amp;</span> end <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>; i<span style=color:#ff79c6>++</span>){
</span></span><span style=display:flex><span>            end <span style=color:#ff79c6>=</span> end.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(end <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>){        <span style=color:#6272a4>// 如果直接到头了，那就说明没有满足 k 个</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ListNode start <span style=color:#ff79c6>=</span> pre.<span style=color:#50fa7b>next</span>;           <span style=color:#6272a4>// 此处是为记录原始未反转段的起始节点</span>
</span></span><span style=display:flex><span>        ListNode nextStart <span style=color:#ff79c6>=</span> end.<span style=color:#50fa7b>next</span>;       <span style=color:#6272a4>// 记录下一个阶段  起始点</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        end.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;                <span style=color:#6272a4>// 此处是为了进行后面的反转操作，断开此处链接,让后面反转操作知道截断点在哪里</span>
</span></span><span style=display:flex><span>        pre.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> reverse(start);      <span style=color:#6272a4>// 反转操作</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        start.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> nextStart;         <span style=color:#6272a4>// 反转之后，start节点实际是已经最后一个节点了，为了和后面的划分段链接，让他的下一个节点连接上下一段的起始点即可</span>
</span></span><span style=display:flex><span>        pre <span style=color:#ff79c6>=</span> start;                    <span style=color:#6272a4>// pre再次来到下一段的上一个节点，也就是本段的结尾点</span>
</span></span><span style=display:flex><span>        end <span style=color:#ff79c6>=</span> pre;                      <span style=color:#6272a4>// 结束点，准备开始下一段的循环找 k 长度的段操作</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dummy.<span style=color:#50fa7b>next</span>;           <span style=color:#6272a4>// 返回最开始的哨兵</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> ListNode <span style=color:#50fa7b>reverse</span>(ListNode head) {
</span></span><span style=display:flex><span>    ListNode pre <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    ListNode curr <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (curr <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {        <span style=color:#6272a4>// 交换操作</span>
</span></span><span style=display:flex><span>        ListNode next <span style=color:#ff79c6>=</span> curr.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        curr.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> pre;
</span></span><span style=display:flex><span>        pre <span style=color:#ff79c6>=</span> curr;
</span></span><span style=display:flex><span>        curr <span style=color:#ff79c6>=</span> next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> pre;     <span style=color:#6272a4>// 返回哨兵，此处是新的翻转序列的起始节点</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=138-随机链表的复制httpsleetcodecnproblemscopy-list-with-random-pointer><a href=https://leetcode.cn/problems/copy-list-with-random-pointer/>138. 随机链表的复制</a></h2><p>我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>HashMap<span style=color:#ff79c6>&lt;</span>Node,Node<span style=color:#ff79c6>&gt;</span> map <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> Node <span style=color:#50fa7b>copyRandomList</span>(Node head) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (head <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 先进行当前节点的拷贝，在进行next的拷贝，之后现在所有节点都拷贝完了，就可以连接random节点了。</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>map.<span style=color:#50fa7b>containsKey</span>(head)) {
</span></span><span style=display:flex><span>        Node headNew <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> Node(head.<span style=color:#50fa7b>val</span>);   <span style=color:#6272a4>//当前节点的拷贝</span>
</span></span><span style=display:flex><span>        map.<span style=color:#50fa7b>put</span>(head,headNew);  <span style=color:#6272a4>//用来记录已经拷贝的节点，在random拷贝时可以找到对应的节点</span>
</span></span><span style=display:flex><span>        headNew.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> copyRandomList(head.<span style=color:#50fa7b>next</span>);  <span style=color:#6272a4>//next的拷贝</span>
</span></span><span style=display:flex><span>        headNew.<span style=color:#50fa7b>random</span> <span style=color:#ff79c6>=</span> copyRandomList(head.<span style=color:#50fa7b>random</span>);  <span style=color:#6272a4>//random的拷贝</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> map.<span style=color:#50fa7b>get</span>(head);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=148-排序链表httpsleetcodecnproblemssort-list><a href=https://leetcode.cn/problems/sort-list/>148. 排序链表</a></h2><p>**进阶：**你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>需要用到<strong>归并排序</strong>的思想。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 归并排序
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param head
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ListNode <span style=color:#50fa7b>sortList2</span>(ListNode head) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (head <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> head.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode midNode <span style=color:#ff79c6>=</span> middleNode(head);  <span style=color:#6272a4>//左面</span>
</span></span><span style=display:flex><span>    ListNode rightHead <span style=color:#ff79c6>=</span> midNode.<span style=color:#50fa7b>next</span>;  <span style=color:#6272a4>//右面</span>
</span></span><span style=display:flex><span>    midNode.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;  <span style=color:#6272a4>//断链</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode left <span style=color:#ff79c6>=</span> sortList2(head);
</span></span><span style=display:flex><span>    ListNode right <span style=color:#ff79c6>=</span> sortList2(rightHead);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> mergeTwoLists(left,right);  <span style=color:#6272a4>//合并</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//  合并两个有序链表（21. 合并两个有序链表）</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> ListNode <span style=color:#50fa7b>mergeTwoLists</span>(ListNode left, ListNode right) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> right;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (right <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> left;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode dummy <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ListNode();
</span></span><span style=display:flex><span>    ListNode cur <span style=color:#ff79c6>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (left.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&gt;</span> right.<span style=color:#50fa7b>val</span>) {
</span></span><span style=display:flex><span>            cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> right;
</span></span><span style=display:flex><span>            right <span style=color:#ff79c6>=</span> right.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> left;
</span></span><span style=display:flex><span>            left <span style=color:#ff79c6>=</span> left.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>?</span> left : right;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dummy.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 找到链表中间节点（876. 链表的中间结点）</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> ListNode <span style=color:#50fa7b>middleNode</span>(ListNode head) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (head <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> head.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode slow <span style=color:#ff79c6>=</span> head;
</span></span><span style=display:flex><span>    ListNode fast <span style=color:#ff79c6>=</span> head.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (fast <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> fast.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        slow <span style=color:#ff79c6>=</span> slow.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        fast <span style=color:#ff79c6>=</span> fast.<span style=color:#50fa7b>next</span>.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> slow;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=23-合并-k-个升序链表httpsleetcodecnproblemsmerge-k-sorted-listsac><a href=https://leetcode.cn/problems/merge-k-sorted-lists/>23. 合并 K 个升序链表</a>(ac)</h2><p>也是采用归并排序的思想。使用K路归并，从而两两递归合并。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ListNode <span style=color:#50fa7b>mergeKLists</span>(ListNode<span style=color:#ff79c6>[]</span> lists) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> mergeK(lists);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> ListNode <span style=color:#50fa7b>mergeK</span>(ListNode<span style=color:#ff79c6>[]</span> lists) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (lists.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> 0) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 当列表只剩下一个数组或为空时，直接返回</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (lists.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>==</span> 1) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> lists<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 递归地将数组列表分为两部分并合并</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> mid <span style=color:#ff79c6>=</span> lists.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>    ListNode<span style=color:#ff79c6>[]</span> left <span style=color:#ff79c6>=</span> Arrays.<span style=color:#50fa7b>copyOfRange</span>(lists,0,mid);
</span></span><span style=display:flex><span>    ListNode<span style=color:#ff79c6>[]</span> right <span style=color:#ff79c6>=</span> Arrays.<span style=color:#50fa7b>copyOfRange</span>(lists,mid,lists.<span style=color:#50fa7b>length</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode leftMerged <span style=color:#ff79c6>=</span> mergeK(left);
</span></span><span style=display:flex><span>    ListNode rightMerged <span style=color:#ff79c6>=</span> mergeK(right);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 合并两个已排序的数组</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> mergeTwoLists(leftMerged, rightMerged);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> ListNode <span style=color:#50fa7b>mergeTwoLists</span>(ListNode left, ListNode right) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> right;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (right <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> left;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode dummy <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ListNode();
</span></span><span style=display:flex><span>    ListNode cur <span style=color:#ff79c6>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (left.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>&gt;</span> right.<span style=color:#50fa7b>val</span>) {
</span></span><span style=display:flex><span>            cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> right;
</span></span><span style=display:flex><span>            right <span style=color:#ff79c6>=</span> right.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> left;
</span></span><span style=display:flex><span>            left <span style=color:#ff79c6>=</span> left.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cur.<span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>?</span> left : right;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dummy.<span style=color:#50fa7b>next</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=146-lru-缓存httpsleetcodecnproblemslru-cache><a href=https://leetcode.cn/problems/lru-cache/>146. LRU 缓存</a></h2><p><code>LinkedHashMap</code>可以实现LRU缓存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>super</span>(capacity,0.<span style=color:#50fa7b>75f</span>,<span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 容量、加载因子、是否读取顺序排序</span>
</span></span></code></pre></div><p>只要复写<code> removeEldestEntry()</code>函数，就能拥有我们自己的缓存策略！</p><h2 id=543-二叉树的直径httpsleetcodecnproblemsdiameter-of-binary-tree><a href=https://leetcode.cn/problems/diameter-of-binary-tree/>543. 二叉树的直径</a></h2><p>与<a href=https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html>9. 二叉树的最大深度</a>有相似的思路</p><pre tabindex=0><code>* 因为需要返回参与的节点数所以需要后序遍历
* 单层逻辑：到中间节点的时候需要就算该根节点左面到右面的最大长度
* 返回值：因为过了该中间节点只能选左右的一边，所以选更大的一面
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 1;  <span style=color:#6272a4>//表示参与的节点数</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>diameterOfBinaryTree</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    traversal(root);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 因为需要返回参与的节点数所以需要后序遍历
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 单层逻辑：到中间节点的时候需要就算该根节点左面到右面的最大长度
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 返回值：因为过了该中间节点只能选左右的一边，所以选更大的一面
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param root
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>traversal</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> traversal(root.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> traversal(root.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> 1 <span style=color:#ff79c6>+</span> Math.<span style=color:#50fa7b>max</span>(left,right);
</span></span><span style=display:flex><span>    res <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(res, left <span style=color:#ff79c6>+</span> right <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> len;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=124-二叉树中的最大路径和httpsleetcodecnproblemsbinary-tree-maximum-path-sumac><a href=https://leetcode.cn/problems/binary-tree-maximum-path-sum/>124. 二叉树中的最大路径和</a>(ac)</h2><p>和<a href=https://leetcode.cn/problems/diameter-of-binary-tree/>543. 二叉树的直径</a>直径基本相同的思想</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> max <span style=color:#ff79c6>=</span> Integer.<span style=color:#50fa7b>MIN_VALUE</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>maxPathSum</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    traversal(root);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> max;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 后序遍历
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 求出左右节点的最大值
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 如果加上当前节点元素进行判断max
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 返回上层的是当前节点+左右节点的最大值
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param node
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>traversal</span>(TreeNode node) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(node <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(traversal(node.<span style=color:#50fa7b>left</span>),0);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(traversal(node.<span style=color:#50fa7b>right</span>),0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> sum <span style=color:#ff79c6>=</span> node.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>+</span> left <span style=color:#ff79c6>+</span> right;
</span></span><span style=display:flex><span>    max <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(max,sum);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> node.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>+</span> Math.<span style=color:#50fa7b>max</span>(left,right);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=114-二叉树展开为链表httpsleetcodecnproblemsflatten-binary-tree-to-linked-list><a href=https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/>114. 二叉树展开为链表</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 找到当前节点左子树的最右节点，然后将当前节点右子树跟在最右节点后面，
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 之后把左子树放到右子树的位置，
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 之后处理下一个节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param root
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>flatten</span>(TreeNode root) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (root <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (root.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            root <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            TreeNode pre <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>left</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (pre.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                pre <span style=color:#ff79c6>=</span> pre.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            pre.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>            root.<span style=color:#50fa7b>right</span> <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>left</span>;
</span></span><span style=display:flex><span>            root.<span style=color:#50fa7b>left</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            root <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=437-路径总和-iiihttpsleetcodecnproblemspath-sum-iii><a href=https://leetcode.cn/problems/path-sum-iii/>437. 路径总和 III</a></h2><p>方法一：前序遍历，要把每个节点作为根节点都计算到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>pathSum</span>(TreeNode root, <span style=color:#8be9fd>int</span> targetSum) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> target <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>long</span>) targetSum;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> traversal(root,target);
</span></span><span style=display:flex><span>    ans <span style=color:#ff79c6>+=</span> pathSum(root.<span style=color:#50fa7b>left</span>,targetSum);
</span></span><span style=display:flex><span>    ans <span style=color:#ff79c6>+=</span> pathSum(root.<span style=color:#50fa7b>right</span>,targetSum);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>traversal</span>(TreeNode node, <span style=color:#8be9fd>long</span> targetSum) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> sum <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (node <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (node.<span style=color:#50fa7b>val</span> <span style=color:#ff79c6>==</span> targetSum) {
</span></span><span style=display:flex><span>        sum<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum <span style=color:#ff79c6>+=</span> traversal(node.<span style=color:#50fa7b>left</span>,targetSum<span style=color:#ff79c6>-</span>node.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>    sum <span style=color:#ff79c6>+=</span> traversal(node.<span style=color:#50fa7b>right</span>,targetSum<span style=color:#ff79c6>-</span>node.<span style=color:#50fa7b>val</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>方法二：前缀和</p><p>HashMap里存的key是前缀和， value是该前缀和的节点数量，记录数量是因为有出现复数路径的可能。</p><p>如果我们不做状态恢复，当遍历右子树时，左子树中A的信息仍会保留在map中，那此时节点6就会认为A, B都是可追溯到的节点，从而产生错误。</p><p>状态恢复代码的作用就是： 在遍历完一个节点的所有子节点后，将其从map中除去。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 前缀和
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param root
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param targetSum
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>pathSum2</span>(TreeNode root, <span style=color:#8be9fd>int</span> targetSum) {
</span></span><span style=display:flex><span>    Map<span style=color:#ff79c6>&lt;</span>Long, Integer<span style=color:#ff79c6>&gt;</span> occurance <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    occurance.<span style=color:#50fa7b>put</span>(0L, 1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dfs(root, targetSum, 0, occurance);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>dfs</span>(TreeNode root, <span style=color:#8be9fd>int</span> targetSum, <span style=color:#8be9fd>long</span> sumToNow, Map<span style=color:#ff79c6>&lt;</span>Long, Integer<span style=color:#ff79c6>&gt;</span> occurance) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> newSumToNow <span style=color:#ff79c6>=</span> sumToNow <span style=color:#ff79c6>+</span> root.<span style=color:#50fa7b>val</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> occurance.<span style=color:#50fa7b>getOrDefault</span>(newSumToNow <span style=color:#ff79c6>-</span> targetSum, 0);
</span></span><span style=display:flex><span>    occurance.<span style=color:#50fa7b>put</span>(newSumToNow, occurance.<span style=color:#50fa7b>getOrDefault</span>(newSumToNow, 0) <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> dfs(root.<span style=color:#50fa7b>left</span>, targetSum, newSumToNow, occurance);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> dfs(root.<span style=color:#50fa7b>right</span>, targetSum, newSumToNow, occurance);
</span></span><span style=display:flex><span>    occurance.<span style=color:#50fa7b>put</span>(newSumToNow, occurance.<span style=color:#50fa7b>getOrDefault</span>(newSumToNow, 0) <span style=color:#ff79c6>-</span> 1);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> count <span style=color:#ff79c6>+</span> left <span style=color:#ff79c6>+</span> right;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=994-腐烂的橘子httpsleetcodecnproblemsrotting-orangesac><a href=https://leetcode.cn/problems/rotting-oranges/>994. 腐烂的橘子</a>(ac)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dir <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        {1,0},{<span style=color:#ff79c6>-</span>1,0},{0,1},{0,<span style=color:#ff79c6>-</span>1}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * BFS
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 每次遍历都是1周
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param grid
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>orangesRotting</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> grid) {
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]&gt;</span> deque <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> times <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> grid.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 2) {
</span></span><span style=display:flex><span>                deque.<span style=color:#50fa7b>offer</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{i,j});
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 1) {
</span></span><span style=display:flex><span>                count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> count <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>size</span>();
</span></span><span style=display:flex><span>        times<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> len; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> cur <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>poll</span>();
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> curx <span style=color:#ff79c6>=</span> cur<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> cury <span style=color:#ff79c6>=</span> cur<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> 4; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> nextx <span style=color:#ff79c6>=</span> curx <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> nexty <span style=color:#ff79c6>=</span> cury <span style=color:#ff79c6>+</span> dir<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (nextx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nextx <span style=color:#ff79c6>&gt;=</span> grid.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> nexty <span style=color:#ff79c6>&gt;=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 1) {
</span></span><span style=display:flex><span>                    count<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>                    grid<span style=color:#ff79c6>[</span>nextx<span style=color:#ff79c6>][</span>nexty<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 2;
</span></span><span style=display:flex><span>                    deque.<span style=color:#50fa7b>offer</span>(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span>{nextx,nexty});
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (count <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> times;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=208-实现-trie-前缀树httpsleetcodecnproblemsimplement-trie-prefix-tree类型题模板题><a href=https://leetcode.cn/problems/implement-trie-prefix-tree/>208. 实现 Trie (前缀树)</a>(类型题、模板题)</h2><p>文章：https://blog.csdn.net/m0_46202073/article/details/107253959</p><p><img src=/img/2024-07-22-leetcode-note/assets/Snipaste_2024-03-27_17-19-31.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>TrieNode</span> {       <span style=color:#6272a4>// 节点</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> isWord; <span style=color:#6272a4>// 是否是终点</span>
</span></span><span style=display:flex><span>    TrieNode<span style=color:#ff79c6>[]</span> children <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> TrieNode<span style=color:#ff79c6>[</span>26<span style=color:#ff79c6>]</span>; <span style=color:#6272a4>//存储包含的字符</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>Trie</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TrieNode root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>Trie</span>() {
</span></span><span style=display:flex><span>        root <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> TrieNode();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     *【向字典树插入单词word】
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 思路：按照word的字符，从根节点开始，一直向下走：
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 如果遇到null，就new出新节点；如果节点已经存在，cur顺着往下走就可以
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @param word
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>insert</span>(String word) {
</span></span><span style=display:flex><span>        TrieNode cur <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> word.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> TrieNode();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cur.<span style=color:#50fa7b>isWord</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>; <span style=color:#6272a4>// 一个单词插入完毕，此时cur指向的节点即为一个单词的结尾</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 思路：按照word的字符，从根节点开始，一直向下走：
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 如果遇到null，就是没找到，返回false;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 如果找到最后，判断是否是结尾isWord;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @param word
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>search</span>(String word) {
</span></span><span style=display:flex><span>        TrieNode cur <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> word.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> cur.<span style=color:#50fa7b>isWord</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 思路：按照word的字符，从根节点开始，一直向下走：
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 如果遇到null，就是没找到，返回false;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @param prefix
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>startsWith</span>(String prefix) {
</span></span><span style=display:flex><span>        TrieNode cur <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> prefix.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> prefix.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * &gt;&gt;&gt; 经典的search方法，是通过一个cur指针(引用)，根据word的字符，一条路走下去
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     *     &gt;&gt;&gt; 其实，它还有一个思路———每次判断一个节点是否配对 的【递归】写法 ：
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>search2</span>(String word) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> match(word, root, 0);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/* macth方法
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    // 基本思路是：根据word和start得到此时的字符，然后看该字符是否与此时的节点node配对————即node.children[c]有值(!=null)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    // (其实start就相当于非递归写法中的for(i)的i)，用来遍历word
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>match</span>(String word, TrieNode node, <span style=color:#8be9fd>int</span> start){		<span style=color:#6272a4>// 这个三个参数直接背下来，这是模板参数</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(start <span style=color:#ff79c6>==</span> word.<span style=color:#50fa7b>length</span>()){
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> node.<span style=color:#50fa7b>isWord</span>;					<span style=color:#6272a4>// (★) </span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>charAt</span>(start) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> node.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> match(word, node.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span>, start <span style=color:#ff79c6>+</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>相关题目：</p><p><a href=https://leetcode-cn.com/problems/short-encoding-of-words/><strong>【 Leetcode Q820 】单词的压缩编码</strong></a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>minimumLengthEncoding</span>(String<span style=color:#ff79c6>[]</span> words) {
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(words, <span style=color:#ff79c6>new</span> Comparator<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span>() {
</span></span><span style=display:flex><span>        @Override
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>compare</span>(String o1, String o2) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> Integer.<span style=color:#50fa7b>compare</span>(o2.<span style=color:#50fa7b>length</span>(),o1.<span style=color:#50fa7b>length</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    PreTree preTree <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PreTree();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (String word : words) {
</span></span><span style=display:flex><span>        ans <span style=color:#ff79c6>+=</span> preTree.<span style=color:#50fa7b>insert</span>(word);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>PreNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> isWord;
</span></span><span style=display:flex><span>    PreNode<span style=color:#ff79c6>[]</span> children <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PreNode<span style=color:#ff79c6>[</span>26<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 构建一棵倒序的前缀树
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>PreTree</span> {
</span></span><span style=display:flex><span>    PreNode root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>PreTree</span>() {
</span></span><span style=display:flex><span>        root <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PreNode();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 如果是新词的话就统计长度
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @param word
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>insert</span>(String word) {
</span></span><span style=display:flex><span>        PreNode cur <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>boolean</span> isNew <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>length</span>() <span style=color:#ff79c6>-</span> 1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PreNode();
</span></span><span style=display:flex><span>                isNew <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cur.<span style=color:#50fa7b>isWord</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> isNew <span style=color:#ff79c6>?</span> word.<span style=color:#50fa7b>length</span>() <span style=color:#ff79c6>+</span> 1 : 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://leetcode-cn.com/problems/re-space-lcci/><strong>【 Leetcode Q17_13 】恢复空格</strong></a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 前缀树 + DP
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param dictionary
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param sentence
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>respace</span>(String<span style=color:#ff79c6>[]</span> dictionary, String sentence) {
</span></span><span style=display:flex><span>    Arrays.<span style=color:#50fa7b>sort</span>(dictionary, <span style=color:#ff79c6>new</span> Comparator<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span>() {
</span></span><span style=display:flex><span>        @Override
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>compare</span>(String o1, String o2) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> Integer.<span style=color:#50fa7b>compare</span>(o2.<span style=color:#50fa7b>length</span>(),o1.<span style=color:#50fa7b>length</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    PreTree preTree <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PreTree();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (String dic : dictionary) {
</span></span><span style=display:flex><span>        preTree.<span style=color:#50fa7b>insert</span>(dic);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>sentence.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>+</span>1<span style=color:#ff79c6>]</span>; <span style=color:#6272a4>// 以i-1为结尾的字符串有多少个未识别</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;=</span> sentence.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>        List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> search <span style=color:#ff79c6>=</span> preTree.<span style=color:#50fa7b>search</span>(sentence, i <span style=color:#ff79c6>-</span> 1); <span style=color:#6272a4>//搜索以i-1为结尾的字符串匹配情况</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (Integer j : search) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>j<span style=color:#ff79c6>]</span>);  <span style=color:#6272a4>//跟匹配上了的取最小值</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>sentence.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>PreNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> isWord;
</span></span><span style=display:flex><span>    PreNode<span style=color:#ff79c6>[]</span> children <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PreNode<span style=color:#ff79c6>[</span>26<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>PreTree</span> {
</span></span><span style=display:flex><span>    PreNode root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>PreTree</span>() {
</span></span><span style=display:flex><span>        root <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PreNode();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>insert</span>(String word) {
</span></span><span style=display:flex><span>        PreNode cur <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>-</span>1; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PreNode();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cur.<span style=color:#50fa7b>isWord</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 找到 sentence 中以 sentence[end] 为结尾的单词(可能不止一个)，返回这些单词的开头下标 【★关键】
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @param word
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>search</span>(String word, <span style=color:#8be9fd>int</span> end) {
</span></span><span style=display:flex><span>        List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> list <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        PreNode cur <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> end; i <span style=color:#ff79c6>&gt;=</span> 0; i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> word.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>-</span> <span style=color:#f1fa8c>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cur <span style=color:#ff79c6>=</span> cur.<span style=color:#50fa7b>children</span><span style=color:#ff79c6>[</span>c<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (cur.<span style=color:#50fa7b>isWord</span>) {
</span></span><span style=display:flex><span>                list.<span style=color:#50fa7b>add</span>(i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> list;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/><strong>【 Leetcode Q211】 添加与搜索单词-数据结构设计</strong></a></p><p><a href=https://leetcode-cn.com/problems/implement-magic-dictionary/><strong>【 Leetcode Q676 】实现一个魔法字典</strong></a></p><h2 id=79-单词搜索httpsleetcodecnproblemsword-search><a href=https://leetcode.cn/problems/word-search/>79. 单词搜索</a></h2><p>DFS搜索</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dir <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        {1,0},{0,1},{<span style=color:#ff79c6>-</span>1,0},{0,<span style=color:#ff79c6>-</span>1}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>exist</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> board, String word) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[</span>board.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>][</span>board<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> board.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> board<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>boolean</span> flag <span style=color:#ff79c6>=</span> backtracking(board,word,i,j,0,visited);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (flag) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * DFS 遇到满足条件就返回
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param board
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param word
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param i
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param j
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param k
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param visited
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>backtracking</span>(<span style=color:#8be9fd>char</span><span style=color:#ff79c6>[][]</span> board, String word, <span style=color:#8be9fd>int</span> i, <span style=color:#8be9fd>int</span> j, <span style=color:#8be9fd>int</span> k, <span style=color:#8be9fd>boolean</span><span style=color:#ff79c6>[][]</span> visited) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (board<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>!=</span> word.<span style=color:#50fa7b>charAt</span>(k)) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (k <span style=color:#ff79c6>==</span> word.<span style=color:#50fa7b>length</span>() <span style=color:#ff79c6>-</span> 1) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dirs : dir) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> newx <span style=color:#ff79c6>=</span> i <span style=color:#ff79c6>+</span> dirs<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> newy <span style=color:#ff79c6>=</span> j <span style=color:#ff79c6>+</span> dirs<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (newx <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> newx <span style=color:#ff79c6>&gt;=</span> board.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>||</span> newy <span style=color:#ff79c6>&lt;</span> 0 <span style=color:#ff79c6>||</span> newy <span style=color:#ff79c6>&gt;=</span> board<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>visited<span style=color:#ff79c6>[</span>newx<span style=color:#ff79c6>][</span>newy<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>boolean</span> flag <span style=color:#ff79c6>=</span> backtracking(board,word,newx,newy,k<span style=color:#ff79c6>+</span>1,visited);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (flag) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    visited<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=33-搜索旋转排序数组httpsleetcodecnproblemssearch-in-rotated-sorted-arrayac><a href=https://leetcode.cn/problems/search-in-rotated-sorted-array/>33. 搜索旋转排序数组</a>(ac)</h2><p><strong>二分查找</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 从mid中分开一定是一侧有序，另一侧可能有序
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param target
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>search</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> mid <span style=color:#ff79c6>=</span> left <span style=color:#ff79c6>+</span> (right <span style=color:#ff79c6>-</span> left) <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> target) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> mid;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;=</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//左边有序</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;</span> target <span style=color:#ff79c6>&amp;&amp;</span> target <span style=color:#ff79c6>&gt;=</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>//target在left和mid之间</span>
</span></span><span style=display:flex><span>                right <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>//target不在left和mid之间</span>
</span></span><span style=display:flex><span>                left <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//右边有序</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> target <span style=color:#ff79c6>&amp;&amp;</span> target <span style=color:#ff79c6>&lt;=</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>//target在mid和right之间</span>
</span></span><span style=display:flex><span>                left <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>//target不在mid和right之间</span>
</span></span><span style=display:flex><span>                right <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=153-寻找旋转排序数组中的最小值httpsleetcodecnproblemsfind-minimum-in-rotated-sorted-arrayac><a href=https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/>153. 寻找旋转排序数组中的最小值</a>(ac)</h2><p><strong>二分查找</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 找到mid左侧有序的一侧，那么min就是最left的那个，然后让left = mid + 1找mid无序的那侧
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 如果mid右侧有序就减小空间，right = mid - 1;
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>findMin</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> min <span style=color:#ff79c6>=</span> Integer.<span style=color:#50fa7b>MAX_VALUE</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (left <span style=color:#ff79c6>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> mid <span style=color:#ff79c6>=</span> left <span style=color:#ff79c6>+</span> (right <span style=color:#ff79c6>-</span> left) <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&lt;</span> min) {
</span></span><span style=display:flex><span>            min <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>mid<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>&gt;=</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//左边有序</span>
</span></span><span style=display:flex><span>            min <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(min,nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>            left <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>+</span> 1;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//右侧有序就减小空间</span>
</span></span><span style=display:flex><span>            right <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> min;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=394-字符串解码httpsleetcodecnproblemsdecode-stringac><a href=https://leetcode.cn/problems/decode-string/>394. 字符串解码</a>(ac)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 1.仅使用一个栈来存储;
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 2.遇到数字就判断前一个是不是数字，之后拼接压栈;
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 3.当遇到&#39;]&#39;时，开始构建字符串;
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 将&#39;[&#39;之前的字符都拿出来拼接;
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 之后获取数字,再拼接
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 然后再将新字符串压栈
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 4.最后将栈里元素出栈反转
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> String <span style=color:#50fa7b>decodeString</span>(String s) {
</span></span><span style=display:flex><span>    StringBuilder ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> StringBuilder();
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>char</span> c <span style=color:#ff79c6>=</span> s.<span style=color:#50fa7b>charAt</span>(i);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (c <span style=color:#ff79c6>!=</span> <span style=color:#f1fa8c>&#39;]&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> Character.<span style=color:#50fa7b>isDigit</span>(stack.<span style=color:#50fa7b>peek</span>().<span style=color:#50fa7b>charAt</span>(0)) <span style=color:#ff79c6>&amp;&amp;</span> Character.<span style=color:#50fa7b>isDigit</span>(c)) {
</span></span><span style=display:flex><span>                stack.<span style=color:#50fa7b>push</span>(stack.<span style=color:#50fa7b>pop</span>()<span style=color:#ff79c6>+</span>c);
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                stack.<span style=color:#50fa7b>push</span>(String.<span style=color:#50fa7b>valueOf</span>(c));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            StringBuilder sb <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> StringBuilder();
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>peek</span>().<span style=color:#50fa7b>equals</span>(<span style=color:#f1fa8c>&#34;[&#34;</span>)) {
</span></span><span style=display:flex><span>                sb.<span style=color:#50fa7b>append</span>(stack.<span style=color:#50fa7b>pop</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>sb.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> num <span style=color:#ff79c6>=</span> Integer.<span style=color:#50fa7b>parseInt</span>(String.<span style=color:#50fa7b>valueOf</span>(stack.<span style=color:#50fa7b>pop</span>()));
</span></span><span style=display:flex><span>                String sbStr <span style=color:#ff79c6>=</span> sb.<span style=color:#50fa7b>toString</span>();
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;</span> num; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>                    sb.<span style=color:#50fa7b>append</span>(sbStr);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>push</span>(String.<span style=color:#50fa7b>valueOf</span>(sb));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>stack.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>        ans.<span style=color:#50fa7b>append</span>(stack.<span style=color:#50fa7b>pop</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> String.<span style=color:#50fa7b>valueOf</span>(ans.<span style=color:#50fa7b>reverse</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=215-数组中的第k个最大元素httpsleetcodecnproblemskth-largest-element-in-an-array><a href=https://leetcode.cn/problems/kth-largest-element-in-an-array/>215. 数组中的第K个最大元素</a></h2><p><em>使用堆能够ac，但时间复杂度是O(nlogn)</em></p><p><strong>快速选择算法+分治法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 快速选择算法  分治法
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param k
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>quickSelect</span>(List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> nums, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 随机选择基准数</span>
</span></span><span style=display:flex><span>    Random rand <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> Random();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> pivot <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>get</span>(rand.<span style=color:#50fa7b>nextInt</span>(nums.<span style=color:#50fa7b>size</span>()));
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将大于、小于、等于 pivot 的元素划分至 big, small, equal 中</span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> big <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> equal <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> small <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> num : nums) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (num <span style=color:#ff79c6>&gt;</span> pivot)
</span></span><span style=display:flex><span>            big.<span style=color:#50fa7b>add</span>(num);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (num <span style=color:#ff79c6>&lt;</span> pivot)
</span></span><span style=display:flex><span>            small.<span style=color:#50fa7b>add</span>(num);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span>
</span></span><span style=display:flex><span>            equal.<span style=color:#50fa7b>add</span>(num);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 第 k 大元素在 big 中，递归划分</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (k <span style=color:#ff79c6>&lt;=</span> big.<span style=color:#50fa7b>size</span>())
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> quickSelect(big, k);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 第 k 大元素在 small 中，递归划分</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nums.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>-</span> small.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&lt;</span> k)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> quickSelect(small, k <span style=color:#ff79c6>-</span> nums.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>+</span> small.<span style=color:#50fa7b>size</span>());
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 第 k 大元素在 equal 中，直接返回 pivot</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> pivot;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>findKthLargest2</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> numList <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> num : nums) {
</span></span><span style=display:flex><span>        numList.<span style=color:#50fa7b>add</span>(num);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> quickSelect(numList, k);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=295-数据流的中位数httpsleetcodecnproblemsfind-median-from-data-streamac><a href=https://leetcode.cn/problems/find-median-from-data-stream/>295. 数据流的中位数</a>(ac)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>MedianFinder</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 大顶堆存中间值的左面
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * 小顶堆存中间值的右面
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>    PriorityQueue<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> minQueue;
</span></span><span style=display:flex><span>    PriorityQueue<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> maxQueue;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>MedianFinder</span>() {
</span></span><span style=display:flex><span>        minQueue <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PriorityQueue<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        maxQueue <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> PriorityQueue<span style=color:#ff79c6>&lt;&gt;</span>(<span style=color:#ff79c6>new</span> Comparator<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span>() {
</span></span><span style=display:flex><span>            @Override
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>compare</span>(Integer o1, Integer o2) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> Integer.<span style=color:#50fa7b>compare</span>(o2,o1);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>addNum</span>(<span style=color:#8be9fd>int</span> num) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (maxQueue.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>            maxQueue.<span style=color:#50fa7b>add</span>(num);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (num <span style=color:#ff79c6>&gt;</span> maxQueue.<span style=color:#50fa7b>peek</span>()) {
</span></span><span style=display:flex><span>            minQueue.<span style=color:#50fa7b>add</span>(num);
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            maxQueue.<span style=color:#50fa7b>add</span>(num);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (maxQueue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>-</span> minQueue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 1) {
</span></span><span style=display:flex><span>            minQueue.<span style=color:#50fa7b>add</span>(maxQueue.<span style=color:#50fa7b>poll</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>while</span> (minQueue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>-</span> maxQueue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 1) {
</span></span><span style=display:flex><span>            maxQueue.<span style=color:#50fa7b>add</span>(minQueue.<span style=color:#50fa7b>poll</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>double</span> <span style=color:#50fa7b>findMedian</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (minQueue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>==</span> maxQueue.<span style=color:#50fa7b>size</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span>  (<span style=color:#8be9fd>double</span>) (minQueue.<span style=color:#50fa7b>peek</span>() <span style=color:#ff79c6>+</span> maxQueue.<span style=color:#50fa7b>peek</span>()) <span style=color:#ff79c6>/</span> 2;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> maxQueue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> minQueue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>?</span> (<span style=color:#8be9fd>double</span>) maxQueue.<span style=color:#50fa7b>peek</span>() : (<span style=color:#8be9fd>double</span>) minQueue.<span style=color:#50fa7b>peek</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=152-乘积最大子数组httpsleetcodecnproblemsmaximum-product-subarray><a href=https://leetcode.cn/problems/maximum-product-subarray/>152. 乘积最大子数组</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 考虑当前位置如果是一个负数的话，
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 并且我们希望这个积尽可能「负得更多」，即尽可能小。
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 如果当前位置是一个正数的话，
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>maxProduct</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dpmax <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;  <span style=color:#6272a4>// 记录最大的值</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dpmin <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>nums.<span style=color:#50fa7b>length</span><span style=color:#ff79c6>]</span>;  <span style=color:#6272a4>// 记录负数最小的值</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 初始化为nums数组</span>
</span></span><span style=display:flex><span>    System.<span style=color:#50fa7b>arraycopy</span>(nums,0,dpmax,0,nums.<span style=color:#50fa7b>length</span>);
</span></span><span style=display:flex><span>    System.<span style=color:#50fa7b>arraycopy</span>(nums,0,dpmin,0,nums.<span style=color:#50fa7b>length</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dpmax<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(dpmax<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>*</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>, Math.<span style=color:#50fa7b>max</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>, dpmin<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>*</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>        dpmin<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(dpmin<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>*</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>, Math.<span style=color:#50fa7b>min</span>(nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>, dpmax<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> 1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>*</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> dpmax<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        ans <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(ans, dpmax<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=32-最长有效括号httpsleetcodecnproblemslongest-valid-parentheses><a href=https://leetcode.cn/problems/longest-valid-parentheses/>32. 最长有效括号</a></h2><p><code>dp[i]</code> 表示以下标 <code>i</code> 字符结尾的最长有效括号的长度。</p><p>递推公式：</p><ul><li><code>s[i]=‘)’ 且 s[i−1]=‘(’</code>，那么</li></ul><p><code>dp[i] = dp[i-2] + 2</code></p><ul><li><code>s[i]=‘)’ 且 s[i−1]=‘)’</code>也就是字符串形如<code> “……))”</code></li></ul><p>如果 <code>s[i−dp[i−1]−1]=‘(’</code>，那么
<code>dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 栈
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>longestValidParentheses</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//如果为空</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (s <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> s.<span style=color:#50fa7b>length</span>() <span style=color:#ff79c6>==</span> 0) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//建立一个栈</span>
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> stack <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayDeque<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//这一步可以防止当第一个Character是&#39;)&#39;的时候发生越界异常</span>
</span></span><span style=display:flex><span>    stack.<span style=color:#50fa7b>push</span>(<span style=color:#ff79c6>-</span>1);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//System.out.println(stack);</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//可以看到stack是[-1]</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//遍历栈找寻合适的左右括号</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//如果找到左括号则入栈，为寻找对应右括号做铺垫</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;(&#39;</span>) stack.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//如果是右括号则出栈</span>
</span></span><span style=display:flex><span>            stack.<span style=color:#50fa7b>pop</span>();
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//但是如果栈是空的话还是得（单身的）把右括号放进来</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (stack.<span style=color:#50fa7b>isEmpty</span>()) stack.<span style=color:#50fa7b>push</span>(i);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>//当前全部人数减去剩余无法配对的人数（单身）即res</span>
</span></span><span style=display:flex><span>                res <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(res, i <span style=color:#ff79c6>-</span> stack.<span style=color:#50fa7b>peek</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * DP
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>longestValidParentheses2</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>s.<span style=color:#50fa7b>length</span>()<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> s.<span style=color:#50fa7b>length</span>(); i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i) <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;)&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (s.<span style=color:#50fa7b>charAt</span>(i<span style=color:#ff79c6>-</span>1) <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;(&#39;</span>) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> (i <span style=color:#ff79c6>&gt;=</span> 2 <span style=color:#ff79c6>?</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>2<span style=color:#ff79c6>]</span> : 0) <span style=color:#ff79c6>+</span> 2;
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>-</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> 1 <span style=color:#ff79c6>&gt;=</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> s.<span style=color:#50fa7b>charAt</span>(i <span style=color:#ff79c6>-</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> 1) <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;(&#39;</span>) {
</span></span><span style=display:flex><span>                dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> 2 <span style=color:#ff79c6>+</span> ((i <span style=color:#ff79c6>-</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>&gt;=</span> 2 <span style=color:#ff79c6>?</span> dp<span style=color:#ff79c6>[</span>i <span style=color:#ff79c6>-</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>-</span> 2<span style=color:#ff79c6>]</span> : 0);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        res <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(res,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=64-最小路径和httpsleetcodecnproblemsminimum-path-sumac><a href=https://leetcode.cn/problems/minimum-path-sum/>64. 最小路径和</a>(ac)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>minPathSum</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> grid) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m <span style=color:#ff79c6>=</span> grid.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> dp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span><span style=color:#ff79c6>[</span>m<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> n; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> dp<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>+</span> grid<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>,dp<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>) <span style=color:#ff79c6>+</span> grid<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> dp<span style=color:#ff79c6>[</span>m<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>][</span>n<span style=color:#ff79c6>-</span>1<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=136-只出现一次的数字httpsleetcodecnproblemssingle-number><a href=https://leetcode.cn/problems/single-number/>136. 只出现一次的数字</a></h2><ol><li>任何数于0异或为任何数 0 ^ n => n</li><li>相同的数异或为0: n ^ n => 0</li></ol><p>例如：2 ^ 3 ^ 2 ^ 4 ^ 4等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 => 0 ^ 0 ^3 => 3</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>singleNumber</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        ans <span style=color:#ff79c6>^=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=169-多数元素httpsleetcodecnproblemsmajority-elementac><a href=https://leetcode.cn/problems/majority-element/>169. 多数元素</a>(ac)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 选定一个元素设置count为1，如果下一个不相同就count--，相同就count++
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 当count小于0时，当前元素已经被消耗完，需要重新记录
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>majorityElement</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> nums.<span style=color:#50fa7b>length</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> ans) {
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            count<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (count <span style=color:#ff79c6>&lt;</span> 0) {
</span></span><span style=display:flex><span>            ans <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            count <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=75-颜色分类httpsleetcodecnproblemssort-colorsac><a href=https://leetcode.cn/problems/sort-colors/>75. 颜色分类</a>(ac)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 遇到0就排在左边，遇到1就排到右边
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 剩下的中间都是1
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>sortColors</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> nums.<span style=color:#50fa7b>length</span> <span style=color:#ff79c6>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;=</span> right; ) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> tmp <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            nums<span style=color:#ff79c6>[</span>left<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>            left<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>            i<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 2) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> tmp <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>            nums<span style=color:#ff79c6>[</span>right<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> tmp;
</span></span><span style=display:flex><span>            right<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            i<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> left; i <span style=color:#ff79c6>&lt;=</span> right; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        nums<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=287-寻找重复数httpsleetcodecnproblemsfind-the-duplicate-number><a href=https://leetcode.cn/problems/find-the-duplicate-number/>287. 寻找重复数</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 快慢指针 -&gt; 类似环状链表
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param nums
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @return
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>findDuplicate</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[]</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> slow <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> fast <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>do</span> {
</span></span><span style=display:flex><span>        slow <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>slow<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>        fast <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>nums<span style=color:#ff79c6>[</span>fast<span style=color:#ff79c6>]]</span>;
</span></span><span style=display:flex><span>    }<span style=color:#ff79c6>while</span> (slow <span style=color:#ff79c6>!=</span> fast);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    slow <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (slow <span style=color:#ff79c6>!=</span> fast) {
</span></span><span style=display:flex><span>         slow <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>slow<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>         fast <span style=color:#ff79c6>=</span> nums<span style=color:#ff79c6>[</span>fast<span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> slow;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=73-矩阵置零httpsleetcodecnproblemsset-matrix-zeroes><a href=https://leetcode.cn/problems/set-matrix-zeroes/>73. 矩阵置零</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 73.矩阵置零
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 我们可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1) 的额外空间。
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 在实际代码中，我们首先预处理出两个标记变量，
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 接着使用其他行与列去处理第一行与第一列，
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 然后反过来使用第一行与第一列去更新其他行与列，
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * 最后使用两个标记变量更新第一行与第一列即可。
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param matrix
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>setZeroes</span>(<span style=color:#8be9fd>int</span><span style=color:#ff79c6>[][]</span> matrix) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> m <span style=color:#ff79c6>=</span> matrix.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span>.<span style=color:#50fa7b>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> flagRow <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> flagCol <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>            flagCol <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>            flagRow <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>                matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>                matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 1; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0 <span style=color:#ff79c6>||</span> matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0) {
</span></span><span style=display:flex><span>                matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (flagCol) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0; i <span style=color:#ff79c6>&lt;</span> m; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            matrix<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>][</span>0<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (flagRow) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> 0; j <span style=color:#ff79c6>&lt;</span> n; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>            matrix<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>][</span>j<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=230-二叉搜索树中第k小的元素httpsleetcodecnproblemskth-smallest-element-in-a-bst><a href=https://leetcode.cn/problems/kth-smallest-element-in-a-bst/>230. 二叉搜索树中第K小的元素</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>middle230</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> len <span style=color:#ff79c6>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ans <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>1;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>kthSmallest</span>(TreeNode root, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>        traversal(root,k);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>traversal</span>(TreeNode root,<span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        traversal(root.<span style=color:#50fa7b>left</span>,k);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        len<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (len <span style=color:#ff79c6>==</span> k) {
</span></span><span style=display:flex><span>            ans <span style=color:#ff79c6>=</span> root.<span style=color:#50fa7b>val</span>;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        traversal(root.<span style=color:#50fa7b>right</span>,k);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>kthSmallest2</span>(TreeNode root, <span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>        MyBst bst <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> MyBst(root);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> bst.<span style=color:#50fa7b>kthSmallest</span>(k);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>MyBst</span>{
</span></span><span style=display:flex><span>        TreeNode root;
</span></span><span style=display:flex><span>        HashMap<span style=color:#ff79c6>&lt;</span>TreeNode,Integer<span style=color:#ff79c6>&gt;</span> map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>MyBst</span>(TreeNode root) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>root</span> <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>map</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            countNodeNum(root);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>countNodeNum</span>(TreeNode node) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> countNodeNum(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> right <span style=color:#ff79c6>=</span> countNodeNum(node.<span style=color:#50fa7b>right</span>);
</span></span><span style=display:flex><span>            map.<span style=color:#50fa7b>put</span>(node,1<span style=color:#ff79c6>+</span>left<span style=color:#ff79c6>+</span>right);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> map.<span style=color:#50fa7b>get</span>(node);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 返回二叉搜索树中第k小的元素</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>kthSmallest</span>(<span style=color:#8be9fd>int</span> k) {
</span></span><span style=display:flex><span>            TreeNode node <span style=color:#ff79c6>=</span> root;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (node <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>int</span> left <span style=color:#ff79c6>=</span> getNodeNum(node.<span style=color:#50fa7b>left</span>);
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>&lt;</span> k<span style=color:#ff79c6>-</span>1) {
</span></span><span style=display:flex><span>                    node <span style=color:#ff79c6>=</span> node.<span style=color:#50fa7b>right</span>;
</span></span><span style=display:flex><span>                    k <span style=color:#ff79c6>-=</span> left<span style=color:#ff79c6>+</span>1;
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (left <span style=color:#ff79c6>==</span> k<span style=color:#ff79c6>-</span>1) {
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                    node <span style=color:#ff79c6>=</span> node.<span style=color:#50fa7b>left</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> node.<span style=color:#50fa7b>val</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>getNodeNum</span>(TreeNode node) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> map.<span style=color:#50fa7b>getOrDefault</span>(node,0);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class="entry-shang text-center"><p>「真诚赞赏，手留余香」</p><button class="zs show-zs btn btn-bred">赞赏支持</button></div><div class=zs-modal-bg></div><div class=zs-modal-box><div class=zs-modal-head><button type=button class=close>×</button>
<span class=author><a href=https://wangzhendong20.github.io/><img src=/img/favicon.png>SleepingFace Blog</a></span><p class=tip><i></i><span>真诚赞赏，手留余香</span></p></div><div class=zs-modal-body><div class=zs-modal-btns><button class="btn btn-blink" data-num=2>2元</button>
<button class="btn btn-blink" data-num=5>5元</button>
<button class="btn btn-blink" data-num=10>10元</button>
<button class="btn btn-blink" data-num=50>50元</button>
<button class="btn btn-blink" data-num=100>100元</button>
<button class="btn btn-blink" data-num=1>任意金额</button></div><div class=zs-modal-pay><button class="btn btn-bred" id=pay-text>2元</button><p>使用<span id=pay-type>微信</span>扫描二维码完成支付</p><img src=/img/reward/wechat-2.png id=pay-image></div></div><div class=zs-modal-footer><label><input type=radio name=zs-type value=wechat class=zs-type checked><span><span class=zs-wechat><img src=/img/reward/wechat-btn.png></span></label>
<label><input type=radio name=zs-type value=alipay class=zs-type class=zs-alipay><img src=/img/reward/alipay-btn.png></span></label></div></div><script type=text/javascript src=/js/reward.js></script><hr><ul class=pager><li class=next><a href=/2024/07/22/hello-world/ data-toggle=tooltip data-placement=top title="Welcome to SleepingFace Blog">Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=wangzhendong20/wangzhendong20.github.io data-repo-id=***************************** data-category=TECH data-category-id=************************** data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=en crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://tanxiangyuu.github.io>谭总的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:wangzhendong20@163.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/wangzhendong20><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="SleepingFace Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; SleepingFace Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>