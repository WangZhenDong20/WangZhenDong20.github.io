<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="SleepingFace Blog"><meta property="og:type" content="article"><meta property="og:image" content="https://wangzhendong20.github.io//img/home1.jpg"><meta property="twitter:image" content="https://wangzhendong20.github.io//img/home1.jpg"><meta name=title content="spring-Retry & Guava Retry - 快速入门"><meta property="og:title" content="spring-Retry & Guava Retry - 快速入门"><meta property="twitter:title" content="spring-Retry & Guava Retry - 快速入门"><meta name=description content="防止AIGC因异常情况失败，为AIGC任务提供重试机制，提高系统的容错性。本文总结了pring-Retry & Guava Retry的快速入门及一些原理。"><meta property="og:description" content="防止AIGC因异常情况失败，为AIGC任务提供重试机制，提高系统的容错性。本文总结了pring-Retry & Guava Retry的快速入门及一些原理。"><meta property="twitter:description" content="防止AIGC因异常情况失败，为AIGC任务提供重试机制，提高系统的容错性。本文总结了pring-Retry & Guava Retry的快速入门及一些原理。"><meta property="twitter:card" content="summary"><meta name=keyword content="WangZhendong"><link rel="shortcut icon" href=/img/favicon.ico><title>spring-Retry & Guava Retry - 快速入门 | 王振东的博客 | SleepingFace Blog</title>
<link rel=canonical href=/2024/08/04/2024-8-4-SpringRetry&amp;GuavaRetry/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>SleepingFace Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/java/>java</a></li><li><a href=/categories/llm/>llm</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/notes//>NOTES</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home1.jpg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/java title=Java>Java</a></div><h1>spring-Retry & Guava Retry - 快速入门</h1><h2 class=subheading></h2><span class=meta>Posted by
SleepingFace
on
Sunday, August 4, 2024</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=spring-retry--guava-retry>Spring-Retry & Guava Retry</h1><h1 id=spring-retry>Spring Retry</h1><h2 id=spring-retry简介>Spring Retry简介</h2><p>Spring Retry 为 Spring 应用程序提供了声明性重试支持。它主要是针对可能抛出异常的一些调用操作，进行有策略的重试。</p><h2 id=快速入门>快速入门</h2><blockquote><p>这里以<em>SleepingFace BI</em>项目中调用AI接口为例，因为AIGC可能因为异常情况而失败，因此使用重试机制提高系统的容错性。</p></blockquote><h3 id=1方法方式>1.方法方式</h3><blockquote><p>引入依赖</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span> <span style=color:#ff79c6>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;groupId&gt;</span>org.springframework.retry<span style=color:#ff79c6>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;artifactId&gt;</span>spring-retry<span style=color:#ff79c6>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;version&gt;</span>1.2.2.RELEASE<span style=color:#ff79c6>&lt;/version&gt;</span>
</span></span><span style=display:flex><span> <span style=color:#ff79c6>&lt;/dependency&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@Configuration
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>RetryConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Bean
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> RetryTemplate <span style=color:#50fa7b>retryTemplate</span>() {
</span></span><span style=display:flex><span>        Map<span style=color:#ff79c6>&lt;</span>Class<span style=color:#ff79c6>&lt;?</span> <span style=color:#8be9fd;font-style:italic>extends</span> Throwable<span style=color:#ff79c6>&gt;</span>, Boolean<span style=color:#ff79c6>&gt;</span> exceptionMap <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        exceptionMap.<span style=color:#50fa7b>put</span>(BusinessException.<span style=color:#50fa7b>class</span>, <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>        RetryTemplate retryTemplate <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> RetryTemplate();
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 重试策略，参数依次代表：最大尝试次数、可重试的异常映射</span>
</span></span><span style=display:flex><span>        SimpleRetryPolicy retryPolicy <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> SimpleRetryPolicy(3, exceptionMap);
</span></span><span style=display:flex><span>        retryTemplate.<span style=color:#50fa7b>setRetryPolicy</span>(retryPolicy);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 重试间隔时间</span>
</span></span><span style=display:flex><span>        ExponentialBackOffPolicy backOffPolicy <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ExponentialBackOffPolicy();
</span></span><span style=display:flex><span>        backOffPolicy.<span style=color:#50fa7b>setInitialInterval</span>(5000L);
</span></span><span style=display:flex><span>        backOffPolicy.<span style=color:#50fa7b>setMultiplier</span>(1.<span style=color:#50fa7b>5</span>);
</span></span><span style=display:flex><span>        backOffPolicy.<span style=color:#50fa7b>setMaxInterval</span>(60000L);
</span></span><span style=display:flex><span>        retryTemplate.<span style=color:#50fa7b>setBackOffPolicy</span>(backOffPolicy);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> retryTemplate;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RetryTemplate retryTemplate <span style=color:#ff79c6>=</span> retryConfig.<span style=color:#50fa7b>retryTemplate</span>();
</span></span><span style=display:flex><span>result <span style=color:#ff79c6>=</span> retryTemplate.<span style=color:#50fa7b>execute</span>(retryCallback <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> qianWenText.<span style=color:#50fa7b>callWithMessage</span>(textRecordService.<span style=color:#50fa7b>buildUserInput</span>(textRecord,textTask.<span style=color:#50fa7b>getTextType</span>()).<span style=color:#50fa7b>toString</span>()); <span style=color:#6272a4>// 业务逻辑</span>
</span></span><span style=display:flex><span>}, recoveryCallback <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>    channel.<span style=color:#50fa7b>basicNack</span>(deliveryTag,<span style=color:#ff79c6>false</span>,<span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>    log.<span style=color:#50fa7b>warn</span>(<span style=color:#f1fa8c>&#34;信息放入队列{}&#34;</span>, DateTime.<span style=color:#50fa7b>now</span>());
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> BusinessException(ErrorCode.<span style=color:#50fa7b>SYSTEM_ERROR</span>,<span style=color:#f1fa8c>&#34;AI 服务错误&#34;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p><code>RetryTemplate </code>承担了重试执行者的角色，它可以设置<code>SimpleRetryPolicy</code>(重试策略)，<code>ExponentialBackOffPolicy</code>（回退策略）。</p><p>RetryTemplate通过execute提交执行操作，需要准备RetryCallback 和RecoveryCallback 两个类实例，前者对应的就是重试回调逻辑实例，包装正常的功能操作，RecoveryCallback实现的是整个执行操作结束的恢复操作实例.</p><h3 id=2注解方式>2.注解方式</h3><blockquote><p>引入依赖</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#ff79c6>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;groupId&gt;</span>org.springframework.retry<span style=color:#ff79c6>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;artifactId&gt;</span>spring-retry<span style=color:#ff79c6>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;version&gt;</span>1.3.1<span style=color:#ff79c6>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;groupId&gt;</span>org.aspectj<span style=color:#ff79c6>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;artifactId&gt;</span>aspectjweaver<span style=color:#ff79c6>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;version&gt;</span>1.9.1<span style=color:#ff79c6>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&lt;/dependency&gt;</span>
</span></span></code></pre></div><ol><li>在application启动类上加上<code>@EnableRetry</code>的注解</li><li>在需要重试的方法上标注注解<code>@Retryable</code></li></ol><p><code>@Retryable(value = {BusinessException.class},maxAttempts = 3,backoff = @Backoff(delay = 2000L,multiplier = 2))</code></p><p><strong>@Retryable</strong></p><table><thead><tr><th>属性</th><th style=text-align:center>类型</th><th style=text-align:center>默认值</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td>interceptor</td><td style=text-align:center>String</td><td style=text-align:center>""</td><td style=text-align:center>将interceptor的bean名称应用到retryable()</td></tr><tr><td>value</td><td style=text-align:center>Class[]</td><td style=text-align:center>{}</td><td style=text-align:center>可重试的异常类型</td></tr><tr><td>label</td><td style=text-align:center>String</td><td style=text-align:center>""</td><td style=text-align:center>统计报告的唯一标签。如果没有提供，调用者可以选择忽略它，或者提供默认值</td></tr><tr><td>maxAttempts</td><td style=text-align:center>int</td><td style=text-align:center>3</td><td style=text-align:center>尝试的最大次数（包括第一次失败），默认为3次</td></tr><tr><td>backoff</td><td style=text-align:center>@Backoff</td><td style=text-align:center>@Backoff()</td><td style=text-align:center>指定用于重试此操作的backoff属性，默认为空</td></tr></tbody></table><p><strong>@Backoff</strong></p><table><thead><tr><th>属性</th><th style=text-align:center>类型</th><th style=text-align:center>默认值</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td>delay</td><td style=text-align:center>long</td><td style=text-align:center>0</td><td style=text-align:center>如果不设置则默认使用1000毫秒</td></tr><tr><td>maxDelay</td><td style=text-align:center>long</td><td style=text-align:center>0</td><td style=text-align:center>最大重试等待时间</td></tr><tr><td>multiplier</td><td style=text-align:center>long</td><td style=text-align:center>0</td><td style=text-align:center>用于计算下一个延迟的乘数（大于0生效）</td></tr><tr><td>random</td><td style=text-align:center>boolean</td><td style=text-align:center>false</td><td style=text-align:center>随机重试等待时间</td></tr></tbody></table><p>3.<code>@Recover</code>注解的方法当<em>达到最大重试次数,或抛出了一个没有指定进行重试的异常</em>才会执行。</p><h1 id=guava-retry>Guava Retry</h1><h2 id=guava-retry简介>Guava Retry简介</h2><p>guava-retrying 是一个线程安全的 Java 重试类库，提供了一种通用方法去处理任意需要重试的代码，可以方便灵活地控制重试次数、重试时机、重试频率、停止时机等，并具有异常处理功能。</p><p>GitHub地址：https://github.com/rholder/guava-retrying</p><h2 id=快速入门-1>快速入门</h2><blockquote><p>这里以<em>SleepingFace BI</em>项目中调用AI接口为例，因为AIGC可能因为异常情况而失败，因此使用重试机制提高系统的容错性。</p></blockquote><h3 id=引入依赖>引入依赖</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#ff79c6>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;groupId&gt;</span>com.github.rholder<span style=color:#ff79c6>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;artifactId&gt;</span>guava-retrying<span style=color:#ff79c6>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;version&gt;</span>2.0.0<span style=color:#ff79c6>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&lt;/dependency&gt;</span>
</span></span></code></pre></div><h3 id=代码>代码</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Callable<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> callable <span style=color:#ff79c6>=</span> () <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> qianWenText.<span style=color:#50fa7b>callWithMessage</span>(textRecordService.<span style=color:#50fa7b>buildUserInput</span>(textRecord,textTask.<span style=color:#50fa7b>getTextType</span>()).<span style=color:#50fa7b>toString</span>()); <span style=color:#6272a4>// 业务逻辑</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>Retryer<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> retryer <span style=color:#ff79c6>=</span> RetryerBuilder.<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span>newBuilder()
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>retryIfResult</span>(Predicates.<span style=color:#50fa7b>isNull</span>()) <span style=color:#6272a4>// 如果结果为空则重试</span>
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>retryIfExceptionOfType</span>(BusinessException.<span style=color:#50fa7b>class</span>) <span style=color:#6272a4>// 发生自定义异常则重试</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//                .retryIfRuntimeException() // 发生运行时异常则重试</span>
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>withWaitStrategy</span>(WaitStrategies.<span style=color:#50fa7b>incrementingWait</span>(10, TimeUnit.<span style=color:#50fa7b>SECONDS</span>, 60, TimeUnit.<span style=color:#50fa7b>SECONDS</span>)) <span style=color:#6272a4>// 等待</span>
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>withStopStrategy</span>(StopStrategies.<span style=color:#50fa7b>stopAfterAttempt</span>(4)) <span style=color:#6272a4>// 允许执行4次（首次执行 + 最多重试3次）</span>
</span></span><span style=display:flex><span>                .<span style=color:#50fa7b>build</span>();
</span></span><span style=display:flex><span><span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>    result <span style=color:#ff79c6>=</span> retryer.<span style=color:#50fa7b>call</span>(callable); <span style=color:#6272a4>// 执行</span>
</span></span><span style=display:flex><span>} <span style=color:#ff79c6>catch</span> (Exception e) { <span style=color:#6272a4>// 重试次数超过阈值或被强制中断</span>
</span></span><span style=display:flex><span>    channel.<span style=color:#50fa7b>basicNack</span>(deliveryTag,<span style=color:#ff79c6>false</span>,<span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>    log.<span style=color:#50fa7b>warn</span>(<span style=color:#f1fa8c>&#34;信息放入队列{}&#34;</span>, DateTime.<span style=color:#50fa7b>now</span>());
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> BusinessException(ErrorCode.<span style=color:#50fa7b>SYSTEM_ERROR</span>,<span style=color:#f1fa8c>&#34;AI 服务错误&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>1.首先定义了一个 Callable 任务，其中执行我们需要重试的业务逻辑。</p><p>2.通过 RetryerBuilder 构造重试器，构造包含如下部分：</p><p><strong>重试条件：</strong></p><ul><li><code>.retryIfResult(Predicates.isNull())</code>：如果操作的结果为<code>null</code>，则触发重试。</li><li><code>.retryIfExceptionOfType(BusinessException.class)</code>：如果操作抛出<code>BusinessException</code>类型的异常，则触发重试。</li></ul><p><strong>等待策略</strong>：<code>.withWaitStrategy(WaitStrategies.incrementingWait(10, TimeUnit.SECONDS, 10, TimeUnit.SECONDS))</code>，初始等待时间为10秒，每次重试后等待时间递增10秒，最大等待时间是60秒。</p><p><strong>停止策略</strong>：<code>.withStopStrategy(StopStrategies.stopAfterAttempt(4))</code>指定了最多尝试执行操作的次数（包括第一次尝试和重试）。如果第一次尝试加上最多三次重试都不能成功，那么<code>Retryer</code>将停止尝试。</p><p>3.通过 retryer.call 执行任务</p><p>4.当重试次数超过设定值或者被强制中断时，会抛出异常，需要捕获处理</p><h2 id=retryerbuilder-方法><strong>RetryerBuilder 方法</strong></h2><h3 id=重试条件>重试条件</h3><ul><li>根据执行结果判断是否重试 <code>retryIfResult</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RetryerBuilder<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>retryIfResult</span>(@Nonnull Predicate<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> resultPredicate)
</span></span></code></pre></div><ul><li>发生异常时重试</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 发生任何异常都重试</span>
</span></span><span style=display:flex><span>retryIfException()
</span></span><span style=display:flex><span><span style=color:#6272a4>// 发生 Runtime 异常都重试</span>
</span></span><span style=display:flex><span>RetryerBuilder<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>retryIfRuntimeException</span>()
</span></span><span style=display:flex><span><span style=color:#6272a4>// 发生自定义异常时重试</span>
</span></span><span style=display:flex><span>RetryerBuilder<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>retryIfExceptionOfType</span>(@Nonnull Class<span style=color:#ff79c6>&lt;?</span> <span style=color:#8be9fd;font-style:italic>extends</span> Throwable<span style=color:#ff79c6>&gt;</span> exceptionClass)
</span></span><span style=display:flex><span><span style=color:#6272a4>// 匹配到指定类型异常时重试</span>
</span></span><span style=display:flex><span>RetryerBuilder<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>retryIfException</span>(@Nonnull Predicate<span style=color:#ff79c6>&lt;</span>Throwable<span style=color:#ff79c6>&gt;</span> exceptionPredicate)
</span></span></code></pre></div><h3 id=等待策略>等待策略</h3><p>等待策略可以控制重试的时间间隔，通过 withWaitStrategy 方法注册等待策略：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RetryerBuilder<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>withWaitStrategy</span>(@Nonnull WaitStrategy waitStrategy) <span style=color:#8be9fd;font-style:italic>throws</span> IllegalStateException
</span></span></code></pre></div><p>WaitStrategy 是等待策略接口，可通过 WaitStrategies 的方法生成该接口的策略实现类，共有7种策略：</p><ul><li>FixedWaitStrategy：固定等待时长策略，比如每次重试等待5s</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 参数：等待时间，时间单位</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>fixedWait</span>(<span style=color:#8be9fd>long</span> sleepTime, @Nonnull TimeUnit timeUnit) <span style=color:#8be9fd;font-style:italic>throws</span> IllegalStateException
</span></span></code></pre></div><ul><li>RandomWaitStrategy：随机等待时长策略，每次重试等待指定区间的随机时长</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 参数：随机上限，时间单位</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>randomWait</span>(<span style=color:#8be9fd>long</span> maximumTime, @Nonnull TimeUnit timeUnit)
</span></span><span style=display:flex><span><span style=color:#6272a4>// 参数：随机下限，下限时间单位，随机上限，上限时间单位</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>randomWait</span>(<span style=color:#8be9fd>long</span> minimumTime,
</span></span><span style=display:flex><span>                        @Nonnull TimeUnit minimumTimeUnit,
</span></span><span style=display:flex><span>                        <span style=color:#8be9fd>long</span> maximumTime,
</span></span><span style=display:flex><span>                        @Nonnull TimeUnit maximumTimeUnit)
</span></span></code></pre></div><ul><li>IncrementingWaitStrategy：递增等待时长策略，指定初始等待值，然后重试间隔随次数等差递增，比如依次等待10s、30s、60s（递增值为10）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 参数：初始等待时长，初始值时间单位，递增值，递增值时间单位</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>incrementingWait</span>(<span style=color:#8be9fd>long</span> initialSleepTime,
</span></span><span style=display:flex><span>                              @Nonnull TimeUnit initialSleepTimeUnit,
</span></span><span style=display:flex><span>                              <span style=color:#8be9fd>long</span> increment,
</span></span><span style=display:flex><span>                              @Nonnull TimeUnit incrementTimeUnit)
</span></span></code></pre></div><ul><li>ExponentialWaitStrategy：指数等待时长策略，指定初始值，然后每次重试间隔乘2（即间隔为2的幂次方），如依次等待 2s、6s、12s。可以设置最大等待时长，达到最大值后每次重试将等待最大时长。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 无参数（默认初始值为1）</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>exponentialWait</span>()
</span></span><span style=display:flex><span><span style=color:#6272a4>// 参数：最大等待时长，最大等待时间单位（默认初始值为1）</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>exponentialWait</span>(<span style=color:#8be9fd>long</span> maximumTime, @Nonnull TimeUnit maximumTimeUnit)
</span></span><span style=display:flex><span><span style=color:#6272a4>// 参数：初始值，最大等待时长，最大等待时间单位</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>exponentialWait</span>(<span style=color:#8be9fd>long</span> multiplier, <span style=color:#8be9fd>long</span> maximumTime, @Nonnull TimeUnit maximumTimeUnit)
</span></span></code></pre></div><ul><li>FibonacciWaitStrategy ：斐波那契等待时长策略，类似指数等待时长策略，间隔时长为斐波那契数列。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 无参数（默认初始值为1）</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>fibonacciWait</span>()
</span></span><span style=display:flex><span><span style=color:#6272a4>// 参数：最大等待时长，最大等待时间单位（默认初始值为1）</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>fibonacciWait</span>(<span style=color:#8be9fd>long</span> maximumTime, @Nonnull TimeUnit maximumTimeUnit)
</span></span><span style=display:flex><span><span style=color:#6272a4>// 参数：最大等待时长，最大等待时间单位（默认初始值为1）</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>fibonacciWait</span>(<span style=color:#8be9fd>long</span> multiplier, <span style=color:#8be9fd>long</span> maximumTime, @Nonnull TimeUnit maximumTimeUnit)
</span></span></code></pre></div><ul><li>ExceptionWaitStrategy：异常时长等待策略，根据出现的异常类型决定等待的时长</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 参数：异常类型，计算等待时长的函数</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&lt;</span>T <span style=color:#8be9fd;font-style:italic>extends</span> Throwable<span style=color:#ff79c6>&gt;</span> WaitStrategy <span style=color:#50fa7b>exceptionWait</span>(@Nonnull Class<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span> exceptionClass,
</span></span><span style=display:flex><span>                                                 @Nonnull Function<span style=color:#ff79c6>&lt;</span>T, Long<span style=color:#ff79c6>&gt;</span> function)
</span></span></code></pre></div><ul><li>CompositeWaitStrategy ：复合时长等待策略，可以组合多个等待策略，基本可以满足所有等待时长的需求</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 参数：等待策略数组</span>
</span></span><span style=display:flex><span>WaitStrategy <span style=color:#50fa7b>join</span>(WaitStrategy... waitStrategies)
</span></span></code></pre></div><h3 id=阻塞策略>阻塞策略</h3><p>阻塞策略控制当前重试结束至下次重试开始前的行为，通过 withBlockStrategy 方法注册阻塞策略：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RetryerBuilder<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>withBlockStrategy</span>(@Nonnull BlockStrategy blockStrategy) <span style=color:#8be9fd;font-style:italic>throws</span> IllegalStateException
</span></span></code></pre></div><p>BlockStrategy 是等待策略接口，可通过 BlockStrategies 的方法生成实现类，默认只提供一种策略 ThreadSleepStrategy：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@Immutable
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>ThreadSleepStrategy</span> <span style=color:#8be9fd;font-style:italic>implements</span> BlockStrategy {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>      @Override
</span></span><span style=display:flex><span>      <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>block</span>(<span style=color:#8be9fd>long</span> sleepTime) <span style=color:#8be9fd;font-style:italic>throws</span> InterruptedException {
</span></span><span style=display:flex><span>            Thread.<span style=color:#50fa7b>sleep</span>(sleepTime);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=停止策略>停止策略</h3><p>停止策略决定了何时停止重试，比如限制次数、时间等，通过 withStopStrategy 方法注册等待策略：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RetryerBuilder<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>withStopStrategy</span>(@Nonnull StopStrategy stopStrategy) <span style=color:#8be9fd;font-style:italic>throws</span> IllegalStateException
</span></span></code></pre></div><p>可通过 StopStrategies 的方法生成 StopStrategy 接口的策略实现类，共有3种策略：</p><ul><li><p>NeverStopStrategy：永不停止，直到重试成功</p></li><li><p>StopAfterAttemptStrategy：指定最多重试次数，超过次数抛出 RetryException 异常</p></li><li><p>StopAfterDelayStrategy：指定最长重试时间，超时则中断当前任务执行且不再重试，并抛出 RetryException 异常</p></li></ul><h3 id=超时限制>超时限制</h3><p>通过 withAttemptTimeLimiter 方法为任务添加单次执行时间限制，超时则中断执行，继续重试。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RetryerBuilder<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>withAttemptTimeLimiter</span>(@Nonnull AttemptTimeLimiter<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> attemptTimeLimiter)
</span></span></code></pre></div><p>默认提供了两种 AttemptTimeLimiter：</p><ul><li><p>NoAttemptTimeLimit：不限制执行时间</p></li><li><p>FixedAttemptTimeLimit：限制执行时间为固定值</p></li></ul><h3 id=监听器>监听器</h3><p>可以通过 withRetryListener 方法为重试器注册监听器，每次重试结束后，会按注册顺序依次回调 Listener 的 onRetry 方法，可在其中获取到当前执行的信息，比如重试次数等。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>import</span> com.github.rholder.retry.Attempt;
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> com.github.rholder.retry.RetryListener;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>MyRetryListener</span><span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span> <span style=color:#8be9fd;font-style:italic>implements</span> RetryListener {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    @Override
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>onRetry</span>(Attempt<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span> attempt) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 第几次重试,(注意:第一次重试其实是第一次调用)</span>
</span></span><span style=display:flex><span>        System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>print</span>(<span style=color:#f1fa8c>&#34;[retry]time=&#34;</span> <span style=color:#ff79c6>+</span> attempt.<span style=color:#50fa7b>getAttemptNumber</span>());
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 距离第一次重试的延迟</span>
</span></span><span style=display:flex><span>        System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>print</span>(<span style=color:#f1fa8c>&#34;,delay=&#34;</span> <span style=color:#ff79c6>+</span> attempt.<span style=color:#50fa7b>getDelaySinceFirstAttempt</span>());
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 重试结果: 是异常终止, 还是正常返回</span>
</span></span><span style=display:flex><span>        System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>print</span>(<span style=color:#f1fa8c>&#34;,hasException=&#34;</span> <span style=color:#ff79c6>+</span> attempt.<span style=color:#50fa7b>hasException</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>print</span>(<span style=color:#f1fa8c>&#34;,hasResult=&#34;</span> <span style=color:#ff79c6>+</span> attempt.<span style=color:#50fa7b>hasResult</span>());
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 是什么原因导致异常</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (attempt.<span style=color:#50fa7b>hasException</span>()) {
</span></span><span style=display:flex><span>            System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>print</span>(<span style=color:#f1fa8c>&#34;,causeBy=&#34;</span> <span style=color:#ff79c6>+</span> attempt.<span style=color:#50fa7b>getExceptionCause</span>().<span style=color:#50fa7b>toString</span>());
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 正常返回时的结果</span>
</span></span><span style=display:flex><span>            System.<span style=color:#50fa7b>out</span>.<span style=color:#50fa7b>print</span>(<span style=color:#f1fa8c>&#34;,result=&#34;</span> <span style=color:#ff79c6>+</span> attempt.<span style=color:#50fa7b>getResult</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=retryer-类的-call-方法>Retryer 类的 call 方法</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> V <span style=color:#50fa7b>call</span>(Callable<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> callable) <span style=color:#8be9fd;font-style:italic>throws</span> ExecutionException, RetryException {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> startTime <span style=color:#ff79c6>=</span> System.<span style=color:#50fa7b>nanoTime</span>(); <span style=color:#6272a4>// 1. 记录开始时间，用于后续的时间计算</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> attemptNumber <span style=color:#ff79c6>=</span> 1; ; attemptNumber<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>        Attempt<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> attempt;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>            V result <span style=color:#ff79c6>=</span> attemptTimeLimiter.<span style=color:#50fa7b>call</span>(callable); <span style=color:#6272a4>// 2. 执行callable任务，得到attempt</span>
</span></span><span style=display:flex><span>            attempt <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ResultAttempt<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span>(result, attemptNumber, TimeUnit.<span style=color:#50fa7b>NANOSECONDS</span>.<span style=color:#50fa7b>toMillis</span>(System.<span style=color:#50fa7b>nanoTime</span>() <span style=color:#ff79c6>-</span> startTime));
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            attempt <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ExceptionAttempt<span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span>(t, attemptNumber, TimeUnit.<span style=color:#50fa7b>NANOSECONDS</span>.<span style=color:#50fa7b>toMillis</span>(System.<span style=color:#50fa7b>nanoTime</span>() <span style=color:#ff79c6>-</span> startTime));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (RetryListener listener : listeners) { <span style=color:#6272a4>// 3. 如果有监听器，通知</span>
</span></span><span style=display:flex><span>            listener.<span style=color:#50fa7b>onRetry</span>(attempt);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>rejectionPredicate.<span style=color:#50fa7b>apply</span>(attempt)) { <span style=color:#6272a4>// 4. 如果执行callable出现异常，则返回异常的attempt</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> attempt.<span style=color:#50fa7b>get</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (stopStrategy.<span style=color:#50fa7b>shouldStop</span>(attempt)) { <span style=color:#6272a4>// 5. 根据停止策略判断是否停止重试</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> RetryException(attemptNumber, attempt); <span style=color:#6272a4>// 若停止，抛出异常</span>
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>long</span> sleepTime <span style=color:#ff79c6>=</span> waitStrategy.<span style=color:#50fa7b>computeSleepTime</span>(attempt); <span style=color:#6272a4>// 6. 根据等待策略计算休眠时间</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>                blockStrategy.<span style=color:#50fa7b>block</span>(sleepTime); <span style=color:#6272a4>// 7. 根据阻塞策略决定休眠行为，默认为sleep</span>
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                Thread.<span style=color:#50fa7b>currentThread</span>().<span style=color:#50fa7b>interrupt</span>();
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> RetryException(attemptNumber, attempt);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>主要流程如下：</p><ol><li><p>记录开始时间，便于后续判断是否超过限制时间</p></li><li><p>通过 attemptTimeLimiter 执行 callable 任务，得到 attempt。attempt 代表着每次执行，记录了如执行结果、执行次数、距离第一次执行的延迟时间、异常原因等信息。</p><ul><li>如果 attemptTimeLimiter 是 NoAttemptTimeLimit，则直接调用 callable.call 执行。</li><li>如果 attemptTimeLimiter 是 FixedAttemptTimeLimit，则调用 timeLimiter.callWithTimeout 限制执行时间。</li></ul></li><li><p>通知监听器，进行一些回调操作</p></li><li><p>rejectionPredicate 默认为 alwaysFalse，如果执行 callable 出现异常，则 rejectionPredicate 会返回异常的 attempt</p></li><li><p>根据停止策略判断是否停止重试，若停止，抛出 RetryException 异常表示最终重试失败</p></li><li><p>根据等待策略计算休眠时间</p></li><li><p>根据阻塞策略决定休眠行为，默认为 Thread.sleep</p></li></ol><h1 id=spring-retry--guava-retry总结>Spring-Retry & Guava Retry总结</h1><p>我在<em>SleepingFace BI</em>项目里应用了Guava Retry来实现AIGC任务因异常情况出现错误之后的重试机制，因为AIGC有可能返回的结果为空，这时需要也需要进行重试而不是只遇到异常。</p><p>从Spring-Retry 和Guava Retry来看，guava-retry在使用上更加灵活，能根据方法返回值来判断是否重试，正好符合我的需要，而Spring-retry只能根据抛出的异常来进行重试。</p><p><em>来源博客：</em></p><p><em>1.原文链接：https://blog.csdn.net/zzzgd_666/article/details/84377962</em></p><p><em>2.原文链接：https://cloud.tencent.com/developer/article/1752086</em></p><div class="entry-shang text-center"><p>「给个赞赏，支持一下作者吧~」</p><button class="zs show-zs btn btn-bred">赞赏支持</button></div><div class=zs-modal-bg></div><div class=zs-modal-box><div class=zs-modal-head><button type=button class=close>×</button>
<span class=author><a href=https://wangzhendong20.github.io/><img src=/img/favicon.png>SleepingFace Blog</a></span><p class=tip><i></i><span>给个赞赏，支持一下作者吧~</span></p></div><div class=zs-modal-body><div class=zs-modal-btns><button class="btn btn-blink" data-num=2>2元</button>
<button class="btn btn-blink" data-num=5>5元</button>
<button class="btn btn-blink" data-num=10>10元</button>
<button class="btn btn-blink" data-num=50>50元</button>
<button class="btn btn-blink" data-num=100>100元</button>
<button class="btn btn-blink" data-num=1>任意金额</button></div><div class=zs-modal-pay><button class="btn btn-bred" id=pay-text>2元</button><p>使用<span id=pay-type>微信</span>扫描二维码完成支付</p><img src=/img/reward/wechat-2.png id=pay-image></div></div><div class=zs-modal-footer><label><input type=radio name=zs-type value=wechat class=zs-type checked><span><span class=zs-wechat><img src=/img/reward/wechat-btn.png></span></label>
<label><input type=radio name=zs-type value=alipay class=zs-type class=zs-alipay><img src=/img/reward/alipay-btn.png></span></label></div></div><script type=text/javascript src=/js/reward.js></script><hr><ul class=pager><li class=previous><a href=/2024/08/03/2024-8-3-SDK%E5%BC%80%E5%8F%91/ data-toggle=tooltip data-placement=top title="SDK开发 - 快速入门">&larr;
Previous Post</a></li></ul><script src=https://giscus.app/client.js data-repo=wangzhendong20/wangzhendong20.github.io data-repo-id=***************************** data-category=**************************** data-category-id=************************** data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=en crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/java title=java>java
</a><a href=/tags/leetcode title=leetcode>leetcode
</a><a href=/tags/%E7%AE%97%E6%B3%95 title=算法>算法</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://tanxiangyuu.github.io>谭总的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:wangzhendong20@163.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/wangzhendong20><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="SleepingFace Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">&copy; SleepingFace Blog 2024<br><a>欢迎评论哦！</a></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script><script>var _baId="8cc115b1ee28b68ce1138a4281875e00",_hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="//hm.baidu.com/hm.js?"+_baId,e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>