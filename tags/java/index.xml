<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on SleepingFace Blog</title><link>https://wangzhendong20.github.io/tags/java/</link><description>Recent content in Java on SleepingFace Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 17 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://wangzhendong20.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>刷题记录 - 2024/8/17</title><link>https://wangzhendong20.github.io/2024/08/17/2024-08-17-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9520240817/</link><pubDate>Sat, 17 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/17/2024-08-17-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9520240817/</guid><description>658. 找到 K 个最接近的元素 算术评级：4 中等 堆 /** * heap * @param arr * @param k * @param x * @return */ public List&amp;lt;Integer&amp;gt; findClosestElements(int[] arr, int k, int x) { PriorityQueue&amp;lt;int[]&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(k,(a,b) -&amp;gt; b[1]-a[1]); for (int i = 0; i &amp;lt; arr.length; i++) { if (pq.size() &amp;gt;= k) { if (Math.abs(arr[i] - x)</description></item><item><title>刷题记录 - 2024/8/15</title><link>https://wangzhendong20.github.io/2024/08/15/2024-08-15-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9520240815/</link><pubDate>Thu, 15 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/15/2024-08-15-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9520240815/</guid><description>264. 丑数 II 算数评级：5 中等 堆 /** * 每个丑数都可以用较小的丑数乘以2，3，5得到，因此可以用优先队列来维护 * 小顶堆维护丑数，弹出的第n个数就是第n</description></item><item><title>刷题记录 - 2024/8/14</title><link>https://wangzhendong20.github.io/2024/08/14/2024-08-14-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9520240814/</link><pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/14/2024-08-14-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9520240814/</guid><description>373. 查找和最小的 K 对数字 /** * 最小的k对数只能是nums1[0]或nums2[0]中选一个，然后再从其它的里面选择小的。 * 所以可以用小根堆来存。</description></item><item><title>每日一题 - 2024/8/9</title><link>https://wangzhendong20.github.io/2024/08/09/2024-08-09-leetcodeDaily4/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/09/2024-08-09-leetcodeDaily4/</guid><description>每日一题 - 2024/8/9 3132. 找出与数组相加的整数 II 原来做周赛的时候做过一次了。 代码参考：https://leetcode.cn/problems/find</description></item><item><title>Spring Retry &amp; Guava Retry - 快速入门</title><link>https://wangzhendong20.github.io/2024/08/04/2024-8-4-SpringRetry&amp;GuavaRetry/</link><pubDate>Sun, 04 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/04/2024-8-4-SpringRetry&amp;GuavaRetry/</guid><description>Spring Retry &amp;amp; Guava Retry Spring Retry Spring Retry简介 Spring Retry 为 Spring 应用程序提供了声明性重试支持。它主要是针对可能抛出异常的一些调用操作，进行有策略的重试。 快速入门 这里以</description></item><item><title>每日一题 - 2024/8/4</title><link>https://wangzhendong20.github.io/2024/08/04/2024-08-04-leetcodeDaily3/</link><pubDate>Sun, 04 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/04/2024-08-04-leetcodeDaily3/</guid><description>每日一题 - 2024/8/4 572. 另一棵树的子树 经典题目 思路 判断是否是一棵树的子树，那么我们首先想到如何判断两个树是相同的。 判断两个树是否相同有五种情况： 左右子</description></item><item><title>SDK开发 - 快速入门</title><link>https://wangzhendong20.github.io/2024/08/03/2024-8-3-SDK%E5%BC%80%E5%8F%91/</link><pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/03/2024-8-3-SDK%E5%BC%80%E5%8F%91/</guid><description>SDK开发 前言：今天尝试将SleepingFace BI项目中的功能开发为SDK，这样调用者只需要引入依赖，配置ak/sk，然后调用API就可</description></item><item><title>每日一题 - 2024/8/3</title><link>https://wangzhendong20.github.io/2024/08/03/2024-08-03-leetcodeDaily2/</link><pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/03/2024-08-03-leetcodeDaily2/</guid><description>每日一题 - 2024/8/3 [3143. 正方形中的最多点数] 方法一 先用TreeMap记录每个范围正方形内的所有字符， 之后遍历TreeMap，如果遇到相同字符就停止统计</description></item><item><title>每日一题 - 2024/8/2</title><link>https://wangzhendong20.github.io/2024/08/02/2024-08-02-leetcodeDaily1/</link><pubDate>Fri, 02 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/02/2024-08-02-leetcodeDaily1/</guid><description>每日一题 - 2024/8/2 3128. 直角三角形 题目介绍 给你一个二维 int 矩阵 grid 。 请你返回使用 grid 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。 注意： 如果</description></item><item><title>利用AOP实现权限校验和请求响应日志输出</title><link>https://wangzhendong20.github.io/2024/08/01/2024-8-1-AOP/</link><pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/08/01/2024-8-1-AOP/</guid><description>利用AOP实现权限校验和请求响应日志输出 前言： 记录一下在SleepingFace BI项目里利用AOP做了什么？ 权限校验 请求响应日志输出 1. AO</description></item><item><title>代码随想录+leetcode笔记</title><link>https://wangzhendong20.github.io/2024/07/23/leetcode-note/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangzhendong20.github.io/2024/07/23/leetcode-note/</guid><description>一些工具类方法 Collections 排序操作 void reverse(List list)//反转 void shuffle(List list)//随机排序 void sort(List list)//按自然排序的升序排序 void sort(List list, Comparator c)//定制排序，由C</description></item></channel></rss>